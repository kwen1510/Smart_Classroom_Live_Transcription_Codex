<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Classroom - AI Mindmap Mode</title>
    <!-- Use Tailwind CDN for development, but this should be replaced with a build process in production -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Suppress Tailwind production warning
        if (typeof tailwind !== 'undefined') {
            tailwind.config = {
                corePlugins: {
                    preflight: false,
                }
            }
        }
    </script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body { 
            font-family: 'Inter', sans-serif; 
        }
        
        .gradient-bg { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
        }
        
        /* D3.js Mindmap Styles */
        .mindmap-container {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-radius: 12px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .link {
            fill: none;
            stroke: #cbd5e1;
            stroke-width: 2px;
            stroke-opacity: 0.8;
        }
        
        .link:hover {
            stroke: #667eea;
            stroke-width: 3px;
        }
        
        .node circle {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .node circle:hover {
            stroke-width: 3px;
            filter: brightness(1.1);
        }
        
        .node text {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            user-select: none;
            transition: all 0.2s ease;
        }
        
        .text-tooltip {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.4;
        }
        
        /* Chat Styles */
        .chat-message {
            margin-bottom: 12px;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease-out;
        }
        
        .chat-message.user {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }
        
        .chat-message.ai {
            background: #f1f5f9;
            color: #334155;
            border: 1px solid #e2e8f0;
            border-bottom-left-radius: 4px;
        }
        
        .collapsible-response {
            margin-top: 8px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            overflow: hidden;
            background: #f9fafb;
        }
        
        .collapsible-header {
            padding: 8px 12px;
            background: #e5e7eb;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
            display: flex;
            align-items: center;
            justify-content: between;
        }
        
        .collapsible-header:hover {
            background: #d1d5db;
        }
        
        .collapsible-content {
            padding: 12px;
            background: #f9fafb;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            color: #374151;
            border-top: 1px solid #d1d5db;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
        
        .collapsible-content.expanded {
            display: block;
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes nodeEnter {
            from { opacity: 0; transform: scale(0.3); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .node-enter {
            animation: nodeEnter 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        /* Touch optimization */
        .touch-friendly {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Scrollbar styling */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }
        
        .custom-scroll::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body class="bg-gray-50 font-sans">
    <!-- Header -->  
    <header class="gradient-bg text-white shadow-xl">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <div class="w-10 h-10 bg-white/20 rounded-xl flex items-center justify-center backdrop-blur-sm">
                        <i data-lucide="brain-circuit" class="w-6 h-6 text-white"></i>
                    </div>
                    <div>
                        <h1 class="text-xl font-bold">üß† AI Mindmap Mode</h1>
                        <p class="text-white/80 text-sm">Session: <span id="sessionCode" class="font-mono font-semibold">-</span></p>
                    </div>
                </div>
                <div class="flex items-center space-x-3">
                    <a href="admin.html" class="bg-white/20 backdrop-blur-sm px-4 py-2 rounded-lg text-sm font-medium hover:bg-white/30 transition-colors touch-friendly">
                        <i data-lucide="arrow-left" class="w-4 h-4 mr-2"></i>
                        Back to Admin
                    </a>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="max-w-7xl mx-auto p-4 sm:p-6">
        <!-- Initial Setup Section -->
        <div id="setupSection" class="bg-white rounded-xl shadow-lg border border-gray-200 p-6 mb-6">
            <div class="text-center mb-6">
                <h2 class="text-2xl font-bold text-gray-900 mb-2">üß† AI Mindmap Generator</h2>
                <p class="text-gray-600">Transform your speech into beautiful, interactive mindmaps using AI</p>
            </div>
            
            <div class="space-y-4">
                <div>
                    <label for="mainTopicInput" class="block text-sm font-semibold text-gray-700 mb-2">Main Topic</label>
                    <input 
                        id="mainTopicInput" 
                        type="text" 
                        class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-base"
                        placeholder="Enter the main topic for your mindmap..."
                        value=""
                    >
                </div>
                
                <!-- Hidden test data section -->
                <div id="testDataSection" class="hidden">
                    <div>
                        <label for="initialTextInput" class="block text-sm font-semibold text-gray-700 mb-2">Initial Text</label>
                        <textarea 
                            id="initialTextInput" 
                            rows="6" 
                            class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-base resize-vertical"
                            placeholder="Paste your initial text here... For example: 'Cats are fascinating creatures with extraordinary sensory abilities. They possess a third eyelid called the nictitating membrane...'"
                        ></textarea>
                    </div>
                    
                    <div class="flex flex-col sm:flex-row gap-3">
                        <button 
                            id="generateBtn" 
                            class="flex-1 bg-gradient-to-r from-blue-600 to-purple-600 text-white px-6 py-3 rounded-lg hover:from-blue-700 hover:to-purple-700 transition-all duration-200 flex items-center justify-center text-base font-semibold shadow-lg hover:shadow-xl touch-friendly"
                        >
                            <i data-lucide="brain-circuit" class="w-5 h-5 mr-2"></i>
                            Generate Initial Mindmap
                        </button>
                        <button 
                            id="loadTestDataBtn" 
                            class="bg-gradient-to-r from-orange-500 to-pink-500 text-white px-6 py-3 rounded-lg hover:from-orange-600 hover:to-pink-600 transition-all duration-200 flex items-center justify-center text-base font-semibold shadow-lg hover:shadow-xl touch-friendly"
                        >
                            <i data-lucide="zap" class="w-5 h-5 mr-2"></i>
                            üê± Load Cat Example
                        </button>
                        <button 
                            id="clearBtn" 
                            class="bg-gray-500 text-white px-6 py-3 rounded-lg hover:bg-gray-600 transition-colors flex items-center justify-center text-base font-medium touch-friendly"
                        >
                            <i data-lucide="trash-2" class="w-4 h-4 mr-2"></i>
                            Clear
                        </button>
                    </div>
                </div>
                
                <!-- Voice Recording Section -->
                <div class="flex flex-col sm:flex-row gap-3">
                    <button 
                        id="startRecordingBtn" 
                        class="flex-1 bg-gradient-to-r from-green-600 to-blue-600 text-white px-6 py-3 rounded-lg hover:from-green-700 hover:to-blue-700 transition-all duration-200 flex items-center justify-center text-base font-semibold shadow-lg hover:shadow-xl touch-friendly"
                    >
                        <i data-lucide="mic" class="w-5 h-5 mr-2"></i>
                        üé§ Start Auto-Recording
                    </button>
                    <button 
                        id="stopRecordingMainBtn"
                        class="hidden flex-1 bg-gradient-to-r from-red-600 to-red-700 text-white px-6 py-3 rounded-lg hover:from-red-700 hover:to-red-800 transition-all duration-200 flex items-center justify-center text-base font-semibold shadow-lg hover:shadow-xl touch-friendly"
                    >
                        <i data-lucide="square" class="w-5 h-5 mr-2"></i>
                        üõë Stop Recording
                    </button>
                    <div class="flex items-center space-x-2">
                        <label for="intervalInput" class="text-sm font-medium text-gray-700 whitespace-nowrap">Interval:</label>
                        <input 
                            id="intervalInput" 
                            type="number" 
                            min="5" 
                            max="60" 
                            value="10" 
                            class="w-20 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm"
                        >
                        <span class="text-sm text-gray-600">sec</span>
                    </div>
                    <button 
                        id="toggleTestBtn" 
                        class="bg-gray-500 text-white px-6 py-3 rounded-lg hover:bg-gray-600 transition-colors flex items-center justify-center text-base font-medium touch-friendly"
                    >
                        <i data-lucide="settings" class="w-4 h-4 mr-2"></i>
                        Show Test Options
                    </button>
                </div>
                
                <!-- Recording Status -->
                <div id="recordingStatus" class="hidden bg-red-50 border border-red-200 rounded-lg p-4">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center">
                            <div class="w-3 h-3 bg-red-500 rounded-full animate-pulse mr-3"></div>
                            <span class="text-red-800 font-medium">üé§ Auto-Recording Active</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-sm text-gray-600">Interval: <span id="currentInterval">10</span>s</span>
                        </div>
                    </div>
                    <div class="mt-2 text-sm text-red-600">
                        <div class="flex items-center justify-between">
                            <span>üéì <strong>Academic Mode:</strong> Only educational content will be added to mindmap</span>
                            <span class="text-gray-600">Status: <span id="uploadStatus">Ready</span></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="loadingIndicator" class="hidden text-center py-8">
                <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-4"></div>
                <p class="text-gray-600">Processing your speech and updating mindmap...</p>
            </div>
            
            <div id="errorMessage" class="hidden mt-4 p-4 bg-red-50 border border-red-200 rounded-lg text-red-800"></div>
        </div>

        <!-- Main Mindmap Interface -->
        <div id="mindmapInterface" class="hidden">
            <div class="flex gap-6">
                <!-- Mindmap Visualization -->
                <div class="flex-1 bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden">
                    <div class="p-4 border-b border-gray-100 bg-gradient-to-r from-blue-50 to-purple-50">
                        <div class="flex items-center justify-between">
                            <div>
                                <h3 class="text-lg font-bold text-gray-900 flex items-center">
                                    <i data-lucide="network" class="w-5 h-5 mr-2 text-blue-600"></i>
                                    Interactive Mindmap
                                </h3>
                                <p class="text-sm text-gray-600 mt-1">Zoom with mouse wheel, drag to pan, hover for details</p>
                            </div>
                            <div class="flex items-center space-x-2">
                                <button 
                                    id="recenterBtn"
                                    class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors flex items-center text-sm font-medium"
                                >
                                    <i data-lucide="focus" class="w-4 h-4 mr-2"></i>
                                    Recenter
                                </button>
                                
                                <!-- Help tooltip for text expansion -->
                                <div class="relative group">
                                    <button class="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors duration-200 flex items-center text-sm">
                                        <i data-lucide="help-circle" class="w-4 h-4 mr-2"></i>
                                        Help
                                    </button>
                                    <div class="absolute bottom-full left-0 mb-2 w-64 bg-black text-white text-xs rounded-lg py-2 px-3 opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-10">
                                        <strong>üí° Tip:</strong> Click on any text in the mindmap to see the full content if it's truncated. Hover over text to see it's clickable!
                                        <div class="absolute top-full left-4 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-black"></div>
                                    </div>
                                </div>
                                <button 
                                    id="toggleChatBtn"
                                    class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center text-sm font-medium"
                                >
                                    <i data-lucide="message-circle" class="w-4 h-4 mr-2"></i>
                                    Show AI Chat
                                </button>
                                <button 
                                    id="continueRecordingBtn"
                                    class="hidden bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition-colors flex items-center text-sm font-medium"
                                >
                                    <i data-lucide="square" class="w-4 h-4 mr-2"></i>
                                    Stop Recording
                                </button>
                                <button 
                                    id="resetSessionBtn"
                                    class="bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition-colors flex items-center text-sm font-medium"
                                >
                                    <i data-lucide="rotate-ccw" class="w-4 h-4 mr-2"></i>
                                    Reset
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="mindmap-container" style="height: 600px;" id="mindmapContainer">
                        <div class="flex items-center justify-center h-full text-gray-500">
                            <div class="text-center">
                                <i data-lucide="brain-circuit" class="w-16 h-16 mx-auto mb-4 opacity-50"></i>
                                <p class="text-lg font-medium">Your mindmap will appear here</p>
                                <p class="text-sm opacity-75">Enter a topic and start speaking to generate your mindmap</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Session Info Bar -->
                    <div id="sessionInfoBar" class="hidden p-3 border-t border-gray-100 bg-gray-50 text-sm text-gray-600">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-4">
                                <span><strong>Topic:</strong> <span id="currentTopic">-</span></span>
                                <span><strong>Started:</strong> <span id="sessionStartTime">-</span></span>
                                <span><strong>Duration:</strong> <span id="sessionDuration">0:00</span></span>
                            </div>
                            <button 
                                id="saveSessionBtn"
                                class="bg-blue-600 text-white px-3 py-1 rounded text-sm hover:bg-blue-700 transition-colors flex items-center"
                            >
                                <i data-lucide="download" class="w-4 h-4 mr-1"></i>
                                Download JSON
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Chat Panel (Hidden by default, slides in from right) -->
                <div id="chatPanel" class="hidden w-96 bg-white rounded-xl shadow-lg border border-gray-200 flex flex-col" style="height: 680px;">
                    <div class="p-4 border-b border-gray-100 bg-gradient-to-r from-green-50 to-blue-50">
                        <div class="flex items-center justify-between">
                            <div>
                                <h3 class="text-lg font-bold text-gray-900 flex items-center">
                                    <i data-lucide="message-circle" class="w-5 h-5 mr-2 text-green-600"></i>
                                    üí¨ AI Processing Log
                                </h3>
                                <p class="text-sm text-gray-600 mt-1">See how AI processes your speech</p>
                            </div>
                            <button 
                                id="hideChatBtn"
                                class="bg-gray-500 text-white px-3 py-1 rounded text-sm hover:bg-gray-600 transition-colors"
                            >
                                <i data-lucide="x" class="w-4 h-4"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div id="chatMessages" class="flex-1 p-4 overflow-y-auto custom-scroll space-y-3">
                        <div class="text-center text-gray-500 py-8">
                            <i data-lucide="message-square-plus" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                            <p class="text-sm">AI processing logs will appear here when you speak!</p>
                        </div>
                    </div>

                    <div class="p-4 border-t border-gray-100 bg-gray-50">
                        <div class="flex gap-2">
                            <textarea 
                                id="chatInput" 
                                rows="2" 
                                disabled
                                class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm resize-none disabled:bg-gray-100 disabled:cursor-not-allowed"
                                placeholder="Type additional information to add to your mindmap..."
                                onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();addToMindmap();}"
                            ></textarea>
                            <button 
                                id="sendBtn" 
                                disabled
                                class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center touch-friendly"
                                onclick="addToMindmap()"
                            >
                                <i data-lucide="send" class="w-4 h-4"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Dynamic API base URL - works in both development and production
        const API_BASE_URL = (() => {
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                return 'http://localhost:10000';
            }
            // In production, always use HTTPS and current host
            return `https://${window.location.host}`;
        })();
        
        console.log('üåê API Base URL:', API_BASE_URL);
        
        let currentSession = null;
        let currentMindmapData = null;
        let chatHistory = [];
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let recognition = null;
        let sessionStartTime = null;
        let durationTimer = null;
        let stream = null;
        let chunkInterval = 10000; // Default 10 seconds
        let recordingTimeout = null;

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            setupEventListeners();
        });

        function setupEventListeners() {
            document.getElementById('generateBtn').addEventListener('click', generateInitialMindmap);
            document.getElementById('loadTestDataBtn').addEventListener('click', loadTestData);
            document.getElementById('clearBtn').addEventListener('click', clearAll);
            document.getElementById('startRecordingBtn').addEventListener('click', startAutoRecording);
            document.getElementById('stopRecordingMainBtn').addEventListener('click', stopRecording);
            document.getElementById('continueRecordingBtn').addEventListener('click', stopRecording);
            document.getElementById('toggleTestBtn').addEventListener('click', toggleTestSection);
            document.getElementById('toggleChatBtn').addEventListener('click', toggleChatPanel);
            document.getElementById('hideChatBtn').addEventListener('click', hideChatPanel);
            document.getElementById('recenterBtn').addEventListener('click', recenterMindmap);
            document.getElementById('resetSessionBtn').addEventListener('click', resetSession);
            document.getElementById('saveSessionBtn').addEventListener('click', saveSession);
            document.getElementById('intervalInput').addEventListener('change', updateInterval);
        }

        function updateInterval() {
            const intervalInput = document.getElementById('intervalInput');
            const currentIntervalDisplay = document.getElementById('currentInterval');
            
            if (intervalInput) {
                const intervalSeconds = parseInt(intervalInput.value) || 10;
                chunkInterval = intervalSeconds * 1000;
                if (currentIntervalDisplay) {
                    currentIntervalDisplay.textContent = intervalSeconds;
                }
            }
        }

        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('uploadStatus');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = type === 'error' ? 'text-red-600' : 
                                   type === 'success' ? 'text-green-600' : 
                                   type === 'processing' ? 'text-blue-600' : 'text-gray-600';
            }
        }

        async function startAutoRecording() {
            const mainTopic = document.getElementById('mainTopicInput').value.trim();
            
            if (!mainTopic) {
                showError('Please enter a main topic before starting to record.');
                return;
            }

            try {
                // Update interval from input
                updateInterval();
                
                // Create session if it doesn't exist
                if (!currentSession) {
                    await createMindmapSession(mainTopic);
                }

                // Get audio permission
                stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });

                // Update UI - Show recording interface
                isRecording = true;
                document.getElementById('setupSection').classList.add('hidden');
                document.getElementById('mindmapInterface').classList.remove('hidden');
                document.getElementById('recordingStatus').classList.remove('hidden');
                
                // Show/hide recording buttons
                document.getElementById('startRecordingBtn').classList.add('hidden');
                document.getElementById('stopRecordingMainBtn').classList.remove('hidden');
                document.getElementById('continueRecordingBtn').classList.remove('hidden');
                
                // Disable interval input during recording
                document.getElementById('intervalInput').disabled = true;
                
                // Start recording cycles
                startRecordingCycle();
                updateStatus('Recording started', 'success');
                
                console.log(`üé§ Started auto-recording for topic: ${mainTopic} with ${chunkInterval/1000}s intervals`);
                
            } catch (error) {
                console.error('‚ùå Failed to start auto-recording:', error);
                showError('Failed to start recording: ' + error.message);
                isRecording = false;
                
                // Reset button visibility on error
                document.getElementById('startRecordingBtn').classList.remove('hidden');
                document.getElementById('stopRecordingMainBtn').classList.add('hidden');
            }
        }

        async function startRecordingCycle() {
            if (!isRecording || !stream) return;
            
            try {
                console.log(`üé¨ Starting new recording cycle (${chunkInterval}ms)`);
                
                // Use proper WebM/Opus format
                const options = { mimeType: 'audio/webm;codecs=opus' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'audio/webm';
                }
                
                mediaRecorder = new MediaRecorder(stream, options);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        console.log(`üì¶ Received audio chunk: ${event.data.size} bytes`);
                        uploadChunk(event.data);
                    }
                };
                
                mediaRecorder.onerror = (event) => {
                    console.error("‚ùå MediaRecorder error:", event.error);
                    updateStatus("Recording error", "error");
                };
                
                mediaRecorder.onstop = () => {
                    console.log(`‚èπÔ∏è Recording cycle stopped`);
                    
                    // If still recording, start the next cycle
                    if (isRecording) {
                        setTimeout(() => {
                            startRecordingCycle();
                        }, 100); // Brief pause between cycles
                    }
                };
                
                // Start recording
                mediaRecorder.start();
                
                // Stop recording after the specified interval
                recordingTimeout = setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        console.log(`‚è∞ Stopping recording after ${chunkInterval}ms`);
                        mediaRecorder.stop();
                    }
                }, chunkInterval);
                
            } catch (err) {
                console.error("‚ùå Failed to start recording cycle:", err);
                updateStatus("Recording cycle failed", "error");
            }
        }

        async function uploadChunk(blob) {
            const maxRetries = 3;
            let retryCount = 0;
            
            while (retryCount < maxRetries) {
                try {
                    const formData = new FormData();
                    formData.append('file', blob, `chunk_${Date.now()}.webm`);
                    formData.append('sessionCode', currentSession.code);
                    formData.append('mode', 'mindmap'); // Indicate this is for mindmap processing
                    
                    console.log(`üì§ Uploading chunk (attempt ${retryCount + 1}/${maxRetries}): ${blob.size} bytes`);
                    
                    updateStatus(`Uploading audio... (${retryCount + 1}/${maxRetries})`, "processing");
                    
                    // Add timeout to prevent hanging uploads
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                    
                    const response = await fetch(`${API_BASE_URL}/api/transcribe-mindmap-chunk`, {
                        method: 'POST',
                        body: formData,
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Upload failed: ${response.status} ${errorText}`);
                    }
                    
                    const result = await response.json();
                    console.log("‚úÖ Chunk uploaded and processed:", result);
                    
                    // Update mindmap if we got new data
                    if (result.success && result.mindmapData) {
                        currentMindmapData = result.mindmapData;
                        renderMindmap(result.mindmapData);
                        
                        // Add to chat if visible
                        const chatPanel = document.getElementById('chatPanel');
                        if (!chatPanel.classList.contains('hidden') && result.transcript) {
                            addChatMessage('user', result.transcript);
                            if (result.message) {
                                addChatMessage('ai', result.message, result.rawAiResponse);
                            }
                        }
                        
                        updateStatus("Academic content added", "success");
                    } else if (result.success && result.filtered) {
                        // Content was filtered out as non-academic
                        updateStatus("Content filtered (non-academic)", "info");
                        
                        // Add to chat if visible to show what was filtered
                        const chatPanel = document.getElementById('chatPanel');
                        if (!chatPanel.classList.contains('hidden') && result.transcript) {
                            addChatMessage('user', result.transcript);
                            addChatMessage('ai', 'üîç ' + (result.message || 'Content filtered: no academic value detected'), result.rawAiResponse);
                        }
                    } else if (result.transcript && result.transcript.trim()) {
                        updateStatus("Transcribed (no changes)", "info");
                    } else {
                        updateStatus("No speech detected", "info");
                    }
                    
                    // Success - exit retry loop
                    return;
                    
                } catch (err) {
                    console.error(`‚ùå Upload attempt ${retryCount + 1} failed:`, err);
                    retryCount++;
                    
                    if (retryCount < maxRetries) {
                        // Wait before retrying (exponential backoff)
                        const delay = Math.pow(2, retryCount) * 1000; // 2s, 4s, 8s
                        console.log(`‚è≥ Retrying in ${delay/1000} seconds...`);
                        updateStatus(`Upload failed, retrying in ${delay/1000}s...`, "error");
                        
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        // All retries failed
                        console.error("‚ùå All upload attempts failed:", err);
                        updateStatus(`Upload failed: ${err.message}`, "error");
                    }
                }
            }
        }

        function stopRecording() {
            isRecording = false;
            
            // Clear recording timeout
            if (recordingTimeout) {
                clearTimeout(recordingTimeout);
                recordingTimeout = null;
            }
            
            // Stop media recorder
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
            
            // Stop audio stream
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            // Update UI - Show/hide recording buttons
            document.getElementById('recordingStatus').classList.add('hidden');
            document.getElementById('startRecordingBtn').classList.remove('hidden');
            document.getElementById('stopRecordingMainBtn').classList.add('hidden');
            document.getElementById('continueRecordingBtn').classList.add('hidden');
            
            // Re-enable controls
            document.getElementById('intervalInput').disabled = false;
            
            updateStatus('Recording stopped', 'info');
            console.log('üé§ Stopped auto-recording');
        }

        function startDurationTimer() {
            if (durationTimer) clearInterval(durationTimer);
            
            sessionStartTime = new Date();
            const sessionStartTimeEl = document.getElementById('sessionStartTime');
            if (sessionStartTimeEl) {
                sessionStartTimeEl.textContent = sessionStartTime.toLocaleTimeString();
            }
            
            durationTimer = setInterval(() => {
                const now = new Date();
                const duration = Math.floor((now - sessionStartTime) / 1000);
                const minutes = Math.floor(duration / 60);
                const seconds = duration % 60;
                const sessionDurationEl = document.getElementById('sessionDuration');
                if (sessionDurationEl) {
                    sessionDurationEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        function stopDurationTimer() {
            if (durationTimer) {
                clearInterval(durationTimer);
                durationTimer = null;
            }
        }

        async function createMindmapSession(mainTopic) {
            const sessionCode = 'MINDMAP-' + Math.floor(Math.random() * 10000);
            const sessionResponse = await fetch(`${API_BASE_URL}/api/mindmap/session`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    sessionCode, 
                    mainTopic, 
                    interval: 30000 
                })
            });

            if (!sessionResponse.ok) {
                throw new Error('Failed to create session');
            }

            currentSession = { 
                code: sessionCode, 
                mainTopic,
                startTime: new Date(),
                nodeCount: 0,
                speechCount: 0
            };
            
            // Safe DOM updates with null checks
            const sessionCodeEl = document.getElementById('sessionCode');
            if (sessionCodeEl) sessionCodeEl.textContent = sessionCode;
            
            const currentTopicEl = document.getElementById('currentTopic');
            if (currentTopicEl) currentTopicEl.textContent = mainTopic;
            
            const sessionInfoBar = document.getElementById('sessionInfoBar');
            if (sessionInfoBar) sessionInfoBar.classList.remove('hidden');
            
            // Start duration timer
            startDurationTimer();
            
            // Initialize mindmap with main topic as root
            currentMindmapData = {
                name: mainTopic,
                children: []
            };
            
            // Render initial mindmap with topic as root
            renderMindmap(currentMindmapData);
            
            // Enable chat
            const chatInput = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendBtn');
            if (chatInput) chatInput.disabled = false;
            if (sendBtn) sendBtn.disabled = false;
            
            console.log('‚úÖ Created mindmap session:', sessionCode, 'with topic:', mainTopic);
        }

        function recenterMindmap() {
            if (currentMindmapData) {
                // Re-render the mindmap which will auto-center it
                renderMindmap(currentMindmapData);
            }
        }

        function resetSession() {
            if (!currentSession) {
                showError('No active session to reset.');
                return;
            }

            const confirmed = window.confirm('Are you sure you want to reset this session? This will clear all current progress and start fresh with the same topic.');
            if (!confirmed) return;

            const mainTopic = currentSession.mainTopic;
            
            // Stop recording if active
            if (isRecording) {
                stopRecording();
            }
            
            // Stop duration timer
            stopDurationTimer();
            
            // Clear current session data
            currentMindmapData = null;
            chatHistory = [];
            
            // Reset UI state but keep the interface open
            document.getElementById('chatMessages').innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <i data-lucide="message-square-plus" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                    <p class="text-sm">AI processing logs will appear here when you speak!</p>
                </div>
            `;
            
            // Create new session with same topic
            createMindmapSession(mainTopic);
            
            lucide.createIcons();
        }

        async function saveSession() {
            if (!currentSession || !currentMindmapData) {
                showError('No active session to save.');
                return;
            }

            try {
                // Calculate session duration
                const duration = sessionStartTime ? 
                    Math.floor((new Date() - sessionStartTime) / 1000) : 0;
                
                // Count nodes in mindmap
                const nodeCount = countNodes(currentMindmapData);
                
                // Prepare session metadata
                const sessionMetadata = {
                    sessionCode: currentSession.code,
                    mainTopic: currentSession.mainTopic,
                    startTime: sessionStartTime?.toISOString() || new Date().toISOString(),
                    endTime: new Date().toISOString(),
                    duration: duration,
                    durationFormatted: formatDuration(duration),
                    nodeCount: nodeCount,
                    speechInputs: currentSession.speechCount || 0,
                    mindmapData: currentMindmapData,
                    chatHistory: chatHistory,
                    version: "1.0",
                    savedAt: new Date().toISOString()
                };

                // Save to backend database
                const saveResponse = await fetch(`${API_BASE_URL}/api/mindmap/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(sessionMetadata)
                });

                if (saveResponse.ok) {
                    // Also download as JSON file
                    const jsonData = JSON.stringify(sessionMetadata, null, 2);
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `mindmap_${currentSession.mainTopic.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    // Show success message
                    addChatMessage('ai', `‚úÖ Session saved successfully! Duration: ${formatDuration(duration)}, Nodes: ${nodeCount}`, null);
                } else {
                    throw new Error('Failed to save to server');
                }

            } catch (error) {
                console.error('‚ùå Error saving session:', error);
                
                // Fallback: just download the file
                const sessionMetadata = {
                    sessionCode: currentSession.code,
                    mainTopic: currentSession.mainTopic,
                    startTime: sessionStartTime?.toISOString() || new Date().toISOString(),
                    duration: sessionStartTime ? Math.floor((new Date() - sessionStartTime) / 1000) : 0,
                    mindmapData: currentMindmapData,
                    chatHistory: chatHistory,
                    savedAt: new Date().toISOString(),
                    note: "Saved locally due to server error"
                };

                const jsonData = JSON.stringify(sessionMetadata, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mindmap_${currentSession.mainTopic.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showError('Session saved locally, but could not sync with server: ' + error.message);
            }
        }

        function countNodes(node) {
            if (!node) return 0;
            let count = 1; // Count current node
            if (node.children) {
                node.children.forEach(child => {
                    count += countNodes(child);
                });
            }
            return count;
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        async function processSpeechText(text) {
            if (!text || !currentSession) {
                return;
            }

            try {
                console.log('üß† Processing speech:', text);
                
                // Increment speech count
                currentSession.speechCount = (currentSession.speechCount || 0) + 1;
                
                // Show processing in chat if visible
                const chatPanel = document.getElementById('chatPanel');
                if (!chatPanel.classList.contains('hidden')) {
                    addChatMessage('user', text);
                    var thinkingId = addChatMessage('ai', 'Processing speech and updating mindmap...', null, true);
                }

                let response, result;

                // If this is the first speech input, generate initial mindmap
                if (!currentMindmapData || currentMindmapData.children.length === 0) {
                    response = await fetch(`${API_BASE_URL}/api/mindmap/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            sessionCode: currentSession.code, 
                            text: text 
                        })
                    });
                } else {
                    // Expand existing mindmap
                    response = await fetch(`${API_BASE_URL}/api/mindmap/expand`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            sessionCode: currentSession.code, 
                            text: text 
                        })
                    });
                }

                result = await response.json();
                
                // Remove thinking indicator if chat is visible
                if (!chatPanel.classList.contains('hidden')) {
                    const thinkingEl = document.getElementById(thinkingId);
                    if (thinkingEl) thinkingEl.remove();
                }

                if (!response.ok) {
                    throw new Error(result.error || 'Failed to process speech');
                }

                // Update current mindmap data
                currentMindmapData = result.data;

                // Re-render mindmap
                renderMindmap(result.data);

                // Add AI response to chat if visible
                if (!chatPanel.classList.contains('hidden')) {
                    addChatMessage('ai', result.message || 'Mindmap updated successfully!', result.rawAiResponse);
                }

                console.log('‚úÖ Successfully processed speech and updated mindmap');

            } catch (error) {
                console.error('‚ùå Error processing speech:', error);
                if (!document.getElementById('chatPanel').classList.contains('hidden')) {
                    addChatMessage('ai', 'Sorry, I encountered an error while processing your speech: ' + error.message, null);
                }
            }
        }

        function toggleTestSection() {
            const testSection = document.getElementById('testDataSection');
            const toggleBtn = document.getElementById('toggleTestBtn');
            
            if (testSection.classList.contains('hidden')) {
                testSection.classList.remove('hidden');
                toggleBtn.innerHTML = '<i data-lucide="settings" class="w-4 h-4 mr-2"></i>Hide Test Options';
                loadTestData(); // Pre-populate with test data
            } else {
                testSection.classList.add('hidden');
                toggleBtn.innerHTML = '<i data-lucide="settings" class="w-4 h-4 mr-2"></i>Show Test Options';
            }
            lucide.createIcons();
        }

        function toggleChatPanel() {
            const chatPanel = document.getElementById('chatPanel');
            const toggleBtn = document.getElementById('toggleChatBtn');
            
            if (chatPanel.classList.contains('hidden')) {
                chatPanel.classList.remove('hidden');
                toggleBtn.innerHTML = '<i data-lucide="message-circle" class="w-4 h-4 mr-2"></i>Hide AI Chat';
            } else {
                chatPanel.classList.add('hidden');
                toggleBtn.innerHTML = '<i data-lucide="message-circle" class="w-4 h-4 mr-2"></i>Show AI Chat';
            }
            lucide.createIcons();
        }

        function hideChatPanel() {
            const chatPanel = document.getElementById('chatPanel');
            const toggleBtn = document.getElementById('toggleChatBtn');
            
            chatPanel.classList.add('hidden');
            toggleBtn.innerHTML = '<i data-lucide="message-circle" class="w-4 h-4 mr-2"></i>Show AI Chat';
            lucide.createIcons();
        }

        function loadTestData() {
            document.getElementById('mainTopicInput').value = 'Amazing World of Cats';
            document.getElementById('initialTextInput').value = `Cats are truly remarkable creatures with extraordinary sensory abilities. They possess a third eyelid called the nictitating membrane that provides additional protection for their eyes. Their ears are incredibly flexible and can rotate up to 180 degrees, allowing them to pinpoint sounds with amazing accuracy. Most fascinating of all, cats have a special scent organ called the Jacobson's organ located in the roof of their mouth, which helps them analyze chemical information from their environment.

The behavioral patterns of cats are equally impressive. They spend approximately 70% of their lives sleeping, which equals 13 to 16 hours a day. This extensive sleeping helps them conserve energy for hunting activities. Cats are also incredibly vocal animals, capable of producing over 100 different sounds to communicate with humans and other cats. A group of cats is called a 'clowder,' and they use a complex system of body language, vocalizations, and scent marking to communicate.`;
        }

        function clearAll() {
            // Stop recording if active
            if (isRecording) {
                stopRecording();
            }
            
            // Stop duration timer
            stopDurationTimer();
            
            document.getElementById('mainTopicInput').value = '';
            document.getElementById('initialTextInput').value = '';
            document.getElementById('setupSection').classList.remove('hidden');
            document.getElementById('mindmapInterface').classList.add('hidden');
            document.getElementById('recordingStatus').classList.add('hidden');
            document.getElementById('continueRecordingBtn').classList.add('hidden');
            document.getElementById('chatPanel').classList.add('hidden');
            document.getElementById('testDataSection').classList.add('hidden');
            document.getElementById('sessionInfoBar').classList.add('hidden');
            
            // Reset recording UI - Show start button, hide stop button
            document.getElementById('startRecordingBtn').classList.remove('hidden');
            document.getElementById('stopRecordingMainBtn').classList.add('hidden');
            document.getElementById('intervalInput').disabled = false;
            document.getElementById('intervalInput').value = '10';
            updateInterval(); // Update the interval display
            
            // Reset chat
            document.getElementById('chatMessages').innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <i data-lucide="message-square-plus" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                    <p class="text-sm">AI processing logs will appear here when you speak!</p>
                </div>
            `;
            
            // Reset button text
            document.getElementById('toggleChatBtn').innerHTML = '<i data-lucide="message-circle" class="w-4 h-4 mr-2"></i>Show AI Chat';
            document.getElementById('toggleTestBtn').innerHTML = '<i data-lucide="settings" class="w-4 h-4 mr-2"></i>Show Test Options';
            
            // Reset session data
            currentSession = null;
            currentMindmapData = null;
            chatHistory = [];
            sessionStartTime = null;
            
            // Reset recording state
            stream = null;
            recordingTimeout = null;
            
            document.getElementById('chatInput').disabled = true;
            document.getElementById('sendBtn').disabled = true;
            updateStatus('Ready', 'info');
            lucide.createIcons();
        }

        async function generateInitialMindmap() {
            const mainTopic = document.getElementById('mainTopicInput').value.trim();
            const initialText = document.getElementById('initialTextInput').value.trim();
            const generateBtn = document.getElementById('generateBtn');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const errorMessage = document.getElementById('errorMessage');

            if (!mainTopic || !initialText) {
                showError('Please enter both a main topic and initial text.');
                return;
            }

            try {
                // Show loading state
                generateBtn.disabled = true;
                loadingIndicator.classList.remove('hidden');
                errorMessage.classList.add('hidden');

                // Create session
                const sessionCode = 'MINDMAP-' + Math.floor(Math.random() * 10000);
                const sessionResponse = await fetch(`${API_BASE_URL}/api/mindmap/session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        sessionCode, 
                        mainTopic, 
                        interval: 30000 
                    })
                });

                if (!sessionResponse.ok) {
                    throw new Error('Failed to create session');
                }

                // Generate initial mindmap
                const generateResponse = await fetch(`${API_BASE_URL}/api/mindmap/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        sessionCode, 
                        text: initialText 
                    })
                });

                const result = await generateResponse.json();
                if (!generateResponse.ok) {
                    throw new Error(result.error || 'Failed to generate mindmap');
                }

                // Set current session data
                currentSession = { code: sessionCode, mainTopic };
                currentMindmapData = result.data;
                document.getElementById('sessionCode').textContent = sessionCode;

                // Show mindmap interface
                document.getElementById('setupSection').classList.add('hidden');
                document.getElementById('mindmapInterface').classList.remove('hidden');

                // Render mindmap
                setTimeout(() => {
                    renderMindmap(result.data);
                }, 100);

                // Enable chat and add initial messages
                document.getElementById('chatInput').disabled = false;
                document.getElementById('sendBtn').disabled = false;
                
                // Clear chat and add initial messages
                const chatMessages = document.getElementById('chatMessages');
                chatMessages.innerHTML = '';
                
                addChatMessage('user', initialText);
                addChatMessage('ai', 'Initial mindmap generated! You can now add more information using the chat below.', null);

            } catch (error) {
                console.error('Error generating mindmap:', error);
                showError('Failed to generate mindmap: ' + error.message);
            } finally {
                generateBtn.disabled = false;
                loadingIndicator.classList.add('hidden');
            }
        }

        async function addToMindmap() {
            const chatInput = document.getElementById('chatInput');
            const sendBtn = document.getElementById('sendBtn');
            const text = chatInput.value.trim();

            if (!text || !currentSession) {
                return;
            }

            try {
                // Disable input during processing
                sendBtn.disabled = true;
                chatInput.disabled = true;

                // Add user message to chat
                addChatMessage('user', text);

                // Show thinking indicator
                const thinkingId = addChatMessage('ai', 'Analyzing and updating mindmap...', null, true);

                // Send to API
                const response = await fetch(`${API_BASE_URL}/api/mindmap/expand`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        sessionCode: currentSession.code, 
                        text: text 
                    })
                });

                const result = await response.json();
                
                // Remove thinking indicator
                document.getElementById(thinkingId).remove();

                if (!response.ok) {
                    throw new Error(result.error || 'Failed to expand mindmap');
                }

                // Update current mindmap data
                currentMindmapData = result.data;

                // Re-render mindmap
                renderMindmap(result.data);

                // Add AI response to chat with collapsible raw output
                addChatMessage('ai', result.message, result.rawAiResponse);

                // Clear input
                chatInput.value = '';

            } catch (error) {
                console.error('Error expanding mindmap:', error);
                addChatMessage('ai', 'Sorry, I encountered an error while updating the mindmap: ' + error.message, null);
            } finally {
                sendBtn.disabled = false;
                chatInput.disabled = false;
                chatInput.focus();
            }
        }

        function addChatMessage(type, content, rawResponse = null, isTemporary = false) {
            const chatMessages = document.getElementById('chatMessages');
            const messageId = 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            
            const messageEl = document.createElement('div');
            messageEl.id = messageId;
            messageEl.className = `chat-message ${type}`;
            
            let html = `<div>${content}</div>`;
            
            // Add collapsible raw response if provided
            if (rawResponse && type === 'ai') {
                const collapsibleId = 'collapse-' + messageId;
                html += `
                    <div class="collapsible-response">
                        <div class="collapsible-header" onclick="toggleCollapsible('${collapsibleId}')">
                            <span>ü§ñ Raw AI Response</span>
                            <i data-lucide="chevron-down" class="w-4 h-4 ml-auto transition-transform" id="chevron-${collapsibleId}"></i>
                        </div>
                        <div class="collapsible-content" id="${collapsibleId}">
                            ${escapeHtml(rawResponse)}
                        </div>
                    </div>
                `;
            }
            
            messageEl.innerHTML = html;
            chatMessages.appendChild(messageEl);
            
            // Re-initialize icons
            lucide.createIcons();
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return messageId;
        }

        function toggleCollapsible(id) {
            const content = document.getElementById(id);
            const chevron = document.getElementById('chevron-' + id);
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                chevron.style.transform = 'rotate(0deg)';
            } else {
                content.classList.add('expanded');
                chevron.style.transform = 'rotate(180deg)';
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML.replace(/\n/g, '<br>');
        }

        function showFullText(text, event) {
            // Remove any existing tooltip
            d3.selectAll('.text-tooltip').remove();
            
            // Create tooltip
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'text-tooltip')
                .style('position', 'absolute')
                .style('background', 'rgba(0, 0, 0, 0.9)')
                .style('color', 'white')
                .style('padding', '12px 16px')
                .style('border-radius', '8px')
                .style('font-size', '14px')
                .style('max-width', '300px')
                .style('word-wrap', 'break-word')
                .style('box-shadow', '0 4px 12px rgba(0, 0, 0, 0.3)')
                .style('z-index', '1000')
                .style('pointer-events', 'none')
                .style('opacity', 0)
                .text(text);
            
            // Position tooltip
            const x = event ? event.pageX : 0;
            const y = event ? event.pageY : 0;
            
            tooltip
                .style('left', (x + 10) + 'px')
                .style('top', (y - 10) + 'px')
                .transition()
                .duration(200)
                .style('opacity', 1);
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                tooltip.transition()
                    .duration(300)
                    .style('opacity', 0)
                    .remove();
            }, 5000);
            
            // Hide on click anywhere
            d3.select('body').on('click.tooltip', function() {
                tooltip.remove();
                d3.select('body').on('click.tooltip', null);
            });
        }

        function renderMindmap(data) {
            console.log('Rendering mindmap:', data);
            
            if (!data) {
                console.error('No data to render');
                return;
            }

            const container = document.getElementById('mindmapContainer');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Clear existing content
            container.innerHTML = '';

            // Create SVG
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Create zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 3])
                .on('zoom', (event) => {
                    svg.select('g').attr('transform', event.transform);
                });

            svg.call(zoom);

            // Create main group
            const g = svg.append('g');

            // Create hierarchical layout
            const tree = d3.tree().size([height - 100, width - 200]);
            const root = d3.hierarchy(data);
            
            // Assign positions
            tree(root);

            // Create links
            const link = g.selectAll('.link')
                .data(root.links())
                .enter().append('path')
                .attr('class', 'link')
                .attr('d', d3.linkHorizontal()
                    .x(d => d.y + 100)
                    .y(d => d.x));

            // Create nodes (without animation first)
            const node = g.selectAll('.node')
                .data(root.descendants())
                .enter().append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.y + 100},${d.x})`);

            // Add circles to nodes
            node.append('circle')
                .attr('r', 0)
                .style('fill', d => {
                    if (d.depth === 0) return '#667eea'; // Root - blue
                    if (d.depth === 1) return '#10b981'; // Main topics - green
                    if (d.depth === 2) return '#f59e0b'; // Details - yellow
                    return '#ef4444'; // Deep details - red
                })
                .style('stroke', '#fff')
                .style('stroke-width', 2);

            // Add text labels with better wrapping
            node.each(function(d) {
                const nodeGroup = d3.select(this);
                const text = d.data.name;
                const words = text.split(' ');
                const maxCharsPerLine = d.children ? 25 : 30; // Increased character limits
                const maxLines = d.children ? 3 : 4; // Allow more lines
                const lines = [];
                let currentLine = '';

                words.forEach(word => {
                    if ((currentLine + word).length <= maxCharsPerLine) {
                        currentLine += (currentLine ? ' ' : '') + word;
                    } else {
                        if (currentLine) lines.push(currentLine);
                        currentLine = word;
                    }
                });
                if (currentLine) lines.push(currentLine);

                // Show more lines, only truncate if really necessary
                const displayLines = lines.slice(0, maxLines);
                if (lines.length > maxLines) {
                    // Only add ellipsis if we're actually cutting off content
                    const lastLine = displayLines[maxLines - 1];
                    displayLines[maxLines - 1] = lastLine.length > 20 ? 
                        lastLine.slice(0, -3) + '...' : lastLine + '...';
                }

                displayLines.forEach((line, i) => {
                    const textElement = nodeGroup.append('text')
                        .attr('dy', d.children ? -25 + (i * 14) : 5 + (i * 14)) // More spacing between lines
                        .attr('x', d.children ? 0 : 15)
                        .attr('text-anchor', d.children ? 'middle' : 'start')
                        .style('font-size', d.children ? '13px' : '12px') // Slightly larger font
                        .style('font-weight', d.children ? 'bold' : 'normal')
                        .style('fill', '#1e293b')
                        .style('cursor', 'pointer')
                        .text(line);
                    
                    // Add hover effects and click handler
                    textElement
                        .on('mouseover', function() {
                            d3.select(this)
                                .style('fill', '#3b82f6')
                                .style('text-decoration', 'underline');
                        })
                        .on('mouseout', function() {
                            d3.select(this)
                                .style('fill', '#1e293b')
                                .style('text-decoration', 'none');
                        })
                        .on('click', function(event) {
                            event.stopPropagation();
                            showFullText(d.data.name, event);
                        });
                    
                    // Add a small icon indicator if text is truncated
                    if (lines.length > maxLines && i === displayLines.length - 1) {
                        nodeGroup.append('text')
                            .attr('dy', d.children ? -25 + ((i + 1) * 14) : 5 + ((i + 1) * 14))
                            .attr('x', d.children ? 0 : 15)
                            .attr('text-anchor', d.children ? 'middle' : 'start')
                            .style('font-size', '10px')
                            .style('fill', '#6b7280')
                            .style('cursor', 'pointer')
                            .text('(click to expand)')
                            .on('click', function(event) {
                                event.stopPropagation();
                                showFullText(d.data.name, event);
                            });
                    }
                });
            });

            // Now apply entrance animations
            node
                .style('opacity', 0)
                .transition()
                .duration(500)
                .delay((d, i) => i * 50)
                .style('opacity', 1);

            // Animate circles
            node.select('circle')
                .transition()
                .duration(300)
                .delay((d, i) => i * 50 + 200)
                .attr('r', d => d.children ? 8 : 6);

            // Center the visualization
            try {
                const bounds = g.node().getBBox();
                const fullWidth = container.clientWidth;
                const fullHeight = container.clientHeight;
                
                const widthScale = (fullWidth * 0.9) / bounds.width;
                const heightScale = (fullHeight * 0.9) / bounds.height;
                const scale = Math.min(widthScale, heightScale, 1);
                
                const transform = d3.zoomIdentity
                    .translate(
                        fullWidth / 2 - bounds.x * scale - bounds.width * scale / 2,
                        fullHeight / 2 - bounds.y * scale - bounds.height * scale / 2
                    )
                    .scale(scale);

                svg.call(zoom.transform, transform);
                
            } catch (error) {
                console.error('Error centering mindmap:', error);
                // Fallback centering
                const transform = d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(0.8);
                svg.call(zoom.transform, transform);
            }
        }

        function showError(message) {
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function setupSpeechRecognition() {
            if ('webkitSpeechRecognition' in window) {
                recognition = new webkitSpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
                
                recognition.onstart = function() {
                    console.log('üé§ Speech recognition started');
                };
                
                recognition.onresult = function(event) {
                    console.log('üé§ Speech recognition result received');
                    const transcript = event.results[event.results.length - 1][0].transcript;
                    console.log('üìù Transcript:', transcript);
                    processSpeechText(transcript.trim());
                };
                
                recognition.onerror = function(event) {
                    console.error('üé§ Speech recognition error:', event.error);
                    showError('Speech recognition error: ' + event.error);
                };
                
                recognition.onend = function() {
                    console.log('üé§ Speech recognition ended');
                    if (isRecording) {
                        // Restart recognition if we're still supposed to be recording
                        setTimeout(() => {
                            if (isRecording) {
                                recognition.start();
                            }
                        }, 100);
                    }
                };
            } else if ('SpeechRecognition' in window) {
                recognition = new SpeechRecognition();
                // Same setup as above...
            } else {
                console.warn('Speech recognition not supported');
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (currentMindmapData) {
                clearTimeout(window.resizeTimeout);
                window.resizeTimeout = setTimeout(() => {
                    renderMindmap(currentMindmapData);
                }, 250);
            }
        });
    </script>
</body>
</html> 