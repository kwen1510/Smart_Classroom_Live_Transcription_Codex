<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teacher Dashboard - Checkbox Mode - Smart Classroom</title>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'bounce-subtle': 'bounce 1s ease-in-out 2',
                        'ping-slow': 'ping 2s cubic-bezier(0, 0, 0.2, 1) infinite',
                        'fade-in': 'fadeIn 0.5s ease-out',
                        'slide-up': 'slideUp 0.3s ease-out'
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' }
                        },
                        slideUp: {
                            '0%': { opacity: '0', transform: 'translateY(20px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' }
                        }
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .gradient-bg { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .glass { backdrop-filter: blur(10px); background: rgba(255, 255, 255, 0.1); }
        
        /* iPad and touch optimizations */
        @media (max-width: 768px) {
            .mode-btn {
                min-height: 44px; /* Apple's recommended touch target size */
            }
        }
        
        /* Improve touch interactions */
        button, a, input, select, textarea {
            touch-action: manipulation;
        }
        
        /* Better button sizing for touch */
        .touch-friendly {
            min-height: 44px;
            min-width: 44px;
        }
        
        /* Button responsiveness improvements */
        button {
            transition: all 0.15s ease;
        }
        
        button:active:not(:disabled) {
            transform: scale(0.98);
        }
        
        button:disabled {
            pointer-events: none;
        }
        
        /* Loading spinner animation */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        /* Prevent zoom on input focus on iOS */
        @media screen and (-webkit-min-device-pixel-ratio: 0) {
            input[type="text"], input[type="number"], select, textarea {
                font-size: 16px;
            }
        }
        
        /* Responsive navigation fixes */
        .mode-navigation {
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        .mode-navigation::-webkit-scrollbar {
            display: none;
        }
        
        .mode-btn {
            white-space: nowrap;
            flex-shrink: 0;
            min-width: fit-content;
        }
        
        /* Ensure header doesn't overflow */
        .header-content {
            min-width: 0;
            overflow: hidden;
        }
        
        /* Better responsive navigation */
        @media (max-width: 768px) {
            .mode-navigation {
                min-width: 0;
                flex: 1;
            }
            
            .mode-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.75rem;
                min-width: auto;
                flex: 1;
            }
            
            .mode-btn span {
                display: none;
            }
            
            .mode-btn i {
                margin-right: 0;
                width: 1rem;
                height: 1rem;
            }
            
            /* Make header more compact on mobile */
            .header-title {
                font-size: 1.25rem;
            }
            
            .header-subtitle {
                font-size: 0.75rem;
            }
        }
        
        @media (max-width: 640px) {
            .header-nav-container {
                flex-direction: column;
                gap: 0.75rem;
                align-items: stretch;
            }
            
            .mode-navigation {
                width: 100%;
                justify-content: space-between;
            }
            
            .mode-btn {
                flex: 1;
                justify-content: center;
                padding: 0.75rem 0.5rem;
            }
        }
        
        /* Prevent text overflow in titles */
        .truncate-text {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 200px;
        }
        
        @media (max-width: 480px) {
            .truncate-text {
                max-width: 120px;
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <header class="gradient-bg text-white shadow-xl">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3 sm:py-4">
            <div class="flex items-center justify-between header-content header-nav-container">
                <div class="flex items-center space-x-3 sm:space-x-4 min-w-0 flex-shrink">
                    <div class="w-8 h-8 sm:w-10 sm:h-10 bg-white/20 rounded-xl flex items-center justify-center backdrop-blur-sm flex-shrink-0">
                        <i data-lucide="check-square" class="w-5 h-5 sm:w-6 sm:h-6 text-white"></i>
                    </div>
                    <div class="min-w-0">
                        <h1 class="header-title text-lg sm:text-xl font-bold truncate-text">Smart Classroom - Checkbox Mode</h1>
                        <p class="header-subtitle text-white/90 text-xs sm:text-sm">Session: <span id="sessionCode" class="font-mono font-semibold">Loading...</span></p>
                            </div>
                        </div>
                
                <!-- Mode Navigation -->
                <div class="flex items-center space-x-2 sm:space-x-3 flex-shrink-0">
                    <span class="text-sm text-white/80 hidden lg:inline">Modes:</span>
                    <div class="flex bg-white/10 rounded-lg p-1 mode-navigation">
                        <a href="/admin.html" class="mode-btn text-white/80 hover:bg-white/20 hover:text-white px-2 sm:px-3 py-2 rounded text-xs sm:text-sm font-medium transition-colors flex items-center justify-center">
                            <i data-lucide="message-square" class="w-3 h-3 sm:w-4 sm:h-4 mr-1 sm:mr-2 flex-shrink-0"></i>
                            <span class="truncate">Summary</span>
                        </a>
                        <a href="/mindmap.html" class="mode-btn text-white/80 hover:bg-white/20 hover:text-white px-2 sm:px-3 py-2 rounded text-xs sm:text-sm font-medium transition-colors flex items-center justify-center">
                            <i data-lucide="brain-circuit" class="w-3 h-3 sm:w-4 sm:h-4 mr-1 sm:mr-2 flex-shrink-0"></i>
                            <span class="truncate">Mindmap</span>
                        </a>
                        <button class="mode-btn bg-white/20 text-white px-2 sm:px-3 py-2 rounded text-xs sm:text-sm font-medium transition-colors flex items-center justify-center">
                            <i data-lucide="check-square" class="w-3 h-3 sm:w-4 sm:h-4 mr-1 sm:mr-2 flex-shrink-0"></i>
                            <span class="truncate">Checkbox</span>
                        </button>
                        <a href="/data.html" class="mode-btn text-white/80 hover:bg-white/20 hover:text-white px-2 sm:px-3 py-2 rounded text-xs sm:text-sm font-medium transition-colors flex items-center justify-center">
                            <i data-lucide="database" class="w-3 h-3 sm:w-4 sm:h-4 mr-1 sm:mr-2 flex-shrink-0"></i>
                            <span class="truncate">Data</span>
                        </a>
                        <a href="/prompts.html" class="mode-btn text-white/80 hover:bg-white/20 hover:text-white px-2 sm:px-3 py-2 rounded text-xs sm:text-sm font-medium transition-colors flex items-center justify-center">
                            <i data-lucide="file-text" class="w-3 h-3 sm:w-4 sm:h-4 mr-1 sm:mr-2 flex-shrink-0"></i>
                            <span class="truncate">Prompts</span>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </header>
                
                <!-- Recording Controls -->
    <div class="bg-white shadow-sm border-b border-gray-200">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3">
            <div class="flex flex-col sm:flex-row items-center justify-between gap-3">
                <!-- Left Side: Recording Buttons -->
                <div class="flex items-center space-x-2 sm:space-x-3">
                    <button id="startBtn" class="bg-green-500 hover:bg-green-600 text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg font-semibold transition-all duration-200 transform hover:scale-105 shadow-lg flex items-center text-sm sm:text-base touch-friendly">
                        <i data-lucide="play" class="w-4 h-4 sm:w-5 sm:h-5 mr-2"></i>
                        <span class="hidden sm:inline">Start Recording</span>
                        <span class="sm:hidden">Start</span>
                    </button>
                    <button id="stopBtn" disabled class="bg-red-500 hover:bg-red-600 disabled:bg-gray-400 disabled:cursor-not-allowed text-white px-4 sm:px-6 py-2 sm:py-3 rounded-lg font-semibold transition-all duration-200 shadow-lg flex items-center text-sm sm:text-base touch-friendly">
                        <i data-lucide="square" class="w-4 h-4 sm:w-5 sm:h-5 mr-2"></i>
                        <span class="hidden sm:inline">Stop Recording</span>
                        <span class="sm:hidden">Stop</span>
                    </button>
                </div>
                
                <!-- Middle: Status -->
                <div class="flex items-center space-x-4">
                    <div id="connectionStatus" class="flex items-center space-x-2 bg-gray-100 px-3 py-1.5 rounded-full">
                        <div id="connectionDot" class="w-2 h-2 bg-green-400 rounded-full animate-ping-slow"></div>
                        <span id="connectionText" class="text-xs font-medium text-gray-700">Connected</span>
                    </div>
                    <p class="text-gray-600 text-sm">Elapsed: <span id="timeElapsed">0:00</span></p>
            </div>
            
                <!-- Right Side: Interval Control -->
                <div class="flex items-center space-x-2 sm:space-x-3 bg-gray-100 px-3 sm:px-4 py-2 rounded-lg">
                    <div class="flex items-center space-x-2">
                        <label for="intervalInput" class="text-sm font-medium text-gray-700">Recording Interval:</label>
                        <input 
                            type="number" 
                            id="intervalInput" 
                            min="5" 
                            max="60" 
                            value="20" 
                            class="w-20 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm"
                        >
                        <span class="text-sm text-gray-600">seconds</span>
                    </div>
                </div>
                    </div>
                </div>
            </div>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Criteria Setup Section (Collapsible) -->
        <div class="bg-white rounded-xl shadow-lg border border-gray-200 mb-8">
            <button 
                id="criteriaToggle" 
                onclick="toggleCriteriaEditor()"
                class="w-full px-6 py-4 text-left hover:bg-gray-50 transition-colors duration-200"
            >
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-3">
                        <div class="w-8 h-8 bg-green-100 rounded-lg flex items-center justify-center">
                            <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                            </svg>
                        </div>
                        <div>
                            <h3 class="text-lg font-semibold text-gray-900">Discussion Criteria Setup</h3>
                            <p class="text-sm text-gray-600">Set up your discussion question and criteria checklist</p>
                        </div>
                    </div>
                    <svg id="criteriaChevron" class="w-5 h-5 text-gray-400 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                    </svg>
                </div>
            </button>
            
            <div id="criteriaEditor" class="hidden border-t border-gray-200">
                <div class="p-6">
                    <div class="space-y-6">
                        <!-- Scenario/Question Section -->
                        <div>
                            <label for="scenarioInput" class="block text-sm font-medium text-gray-700 mb-2">
                                Discussion Question/Scenario
                            </label>
                            <textarea 
                                id="scenarioInput" 
                                rows="4" 
                                class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent resize-vertical"
                                placeholder="Enter the discussion question or scenario context..."
                            ></textarea>
                        </div>
                        
                        <!-- Criteria Input -->
                        <div>
                            <label for="criteriaInput" class="block text-sm font-medium text-gray-700 mb-2">
                                Criteria Checklist (one per line)
                            </label>
                            
                            <!-- Format Instructions -->
                            <div class="mb-3 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                                <h5 class="text-sm font-semibold text-blue-800 mb-3 flex items-center">
                                    <i data-lucide="info" class="w-4 h-4 mr-2"></i>
                                    📝 Criteria Format Guide
                                </h5>
                                
                                <div class="grid md:grid-cols-2 gap-4">
                                    <!-- Format Explanation -->
                                    <div>
                                        <p class="text-sm text-blue-700 mb-2">
                                            Use this format for each criterion:
                                        </p>
                                        <div class="bg-white p-3 rounded border border-blue-200 font-mono text-sm">
                                            <span class="text-green-600 font-semibold">Description</span> 
                                            <span class="text-gray-600">(</span><span class="text-orange-600 font-semibold">Rubric</span><span class="text-gray-600">)</span>
                                        </div>
                                        <div class="mt-2 text-xs text-blue-600 space-y-1">
                                            <p><span class="text-green-600 font-semibold">Description:</span> What students should demonstrate</p>
                                            <p><span class="text-orange-600 font-semibold">Rubric:</span> Specific criteria for correct answer</p>
                                        </div>
                                    </div>
                                    
                                    <!-- Examples -->
                                    <div>
                                        <p class="text-sm font-medium text-blue-800 mb-2">✅ Good Examples:</p>
                                        <div class="space-y-2 text-xs">
                                            <div class="bg-white p-2 rounded border border-green-200">
                                                <span class="text-green-600">Students explain that back titration is used</span>
                                                <span class="text-gray-500">(</span><span class="text-orange-600">CaCO3 is not soluble in water and cannot be titrated directly</span><span class="text-gray-500">)</span>
                                            </div>
                                            <div class="bg-white p-2 rounded border border-green-200">
                                                <span class="text-green-600">Students identify the need to weigh by difference</span>
                                                <span class="text-gray-500">(</span><span class="text-orange-600">there will be some CaCO3 left, so the weighing bottle must be reweighed</span><span class="text-gray-500">)</span>
                                            </div>
                                        </div>
                                        
                                        <p class="text-sm font-medium text-red-700 mb-2 mt-3">❌ Avoid:</p>
                                        <div class="bg-red-50 p-2 rounded border border-red-200 text-xs text-red-600">
                                            Students understand back titration because it's important...
                                            <br><span class="text-xs text-red-500">(No specific rubric in parentheses)</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- AI Grading Info -->
                                <div class="mt-3 p-2 bg-yellow-50 border border-yellow-200 rounded text-xs text-yellow-800">
                                    <strong>🤖 AI Grading:</strong> Green = Correct & Complete | Red = Attempted but Wrong | Grey = Not Discussed
                                </div>
                            </div>
                            
                            <textarea 
                                id="criteriaInput" 
                                rows="8" 
                                class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                                placeholder="Students explain that back titration is used (CaCO3 is not soluble in water and cannot be titrated directly)
Students identify that CaCO3 reacts with known volume of excess HCl (the volume of HCl used must be calculated to ensure that the titre volume is between 20 to 25 cm3)
Students identify the need to weigh by difference (there will be some CaCO3 left, so the weighing bottle must be reweighed)
Students recognise the need to cover the conical flask with a filter funnel (there is acid spray from the reaction between CaCO3 and HCl, cover to minimise loss of HCl)
Students understand that HCl must be diluted before titrating against NaOH (if not the titre volume will be more than 50 cm3, no longer between 20 to 25 cm3)
Students should choose the appropriate indicator (methyl orange or thymolphthalein)
Students recognise to stop titration after 2 consistent results (consistent to 0.10 cm3)"
                            ></textarea>
                            <div class="flex items-center justify-between mt-2">
                                <p class="text-xs text-gray-500">Each line becomes a separate criterion • Use format: <code class="bg-gray-100 px-1 rounded">Description (Rubric)</code></p>
                                <button type="button" onclick="toggleFormatHelp()" class="text-xs text-blue-600 hover:text-blue-800 flex items-center">
                                    <i data-lucide="help-circle" class="w-3 h-3 mr-1"></i>
                                    Format Help
                                </button>
                            </div>
                        </div>
                        
                        <!-- Evaluation Strictness Slider -->
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">
                                Evaluation Strictness
                            </label>
                            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                                <div class="flex items-center justify-between mb-3">
                                    <span class="text-xs text-gray-500">Lenient</span>
                                    <span id="strictnessLabel" class="text-sm font-medium text-blue-600">Moderate</span>
                                    <span class="text-xs text-gray-500">Strict</span>
                                </div>
                                <input 
                                    type="range" 
                                    id="strictnessSlider" 
                                    min="1" 
                                    max="3" 
                                    value="2" 
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                                    oninput="updateStrictnessLabel(this.value)"
                                >
                                <div class="mt-3 text-xs text-gray-600" id="strictnessDescription">
                                    <strong>Moderate:</strong> Balanced evaluation requiring both concept and key details
                                </div>
                            </div>
                            <style>
                                .slider::-webkit-slider-thumb {
                                    appearance: none;
                                    width: 20px;
                                    height: 20px;
                                    background: #3B82F6;
                                    cursor: pointer;
                                    border-radius: 50%;
                                }
                                .slider::-moz-range-thumb {
                                    width: 20px;
                                    height: 20px;
                                    background: #3B82F6;
                                    cursor: pointer;
                                    border-radius: 50%;
                                    border: none;
                                }
                            </style>
                        </div>
                        
                        <!-- Prompt Library Section -->
                        <div class="border-t border-gray-200 pt-6">
                            <div class="flex items-center justify-between mb-4">
                                <h4 class="text-sm font-semibold text-gray-700">Checkbox Prompt Library</h4>
                                <div class="flex gap-2">
                                    <button onclick="refreshCheckboxPrompts()" class="text-xs text-gray-500 hover:text-gray-700 flex items-center">
                                        <i data-lucide="refresh-cw" class="w-3 h-3 mr-1"></i>
                                        Refresh
                                    </button>
                                    <button onclick="openCreateCheckboxPromptModal()" class="text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700 flex items-center">
                                        <i data-lucide="plus" class="w-3 h-3 mr-1"></i>
                                        New
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Search and Filter -->
                            <div class="flex gap-2 mb-3">
                                <div class="flex-1 relative">
                                    <i data-lucide="search" class="absolute left-3 top-1/2 transform -translate-y-1/2 w-3 h-3 text-gray-400"></i>
                                    <input 
                                        id="checkboxPromptSearch" 
                                        type="text" 
                                        placeholder="Search checkbox prompts..." 
                                        class="w-full pl-8 pr-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent"
                                        onkeyup="filterCheckboxPrompts()"
                                    >
                                </div>
                                <select id="checkboxPromptCategoryFilter" class="px-3 py-2 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent" onchange="filterCheckboxPrompts()">
                                    <option value="">All Categories</option>
                                </select>
                            </div>
                            
                            <!-- Prompt Cards Grid -->
                            <div id="checkboxPromptLibraryGrid" class="grid grid-cols-1 md:grid-cols-2 gap-3 max-h-64 overflow-y-auto">
                                <div class="flex items-center justify-center py-8 text-gray-500 text-sm col-span-full">
                                    <i data-lucide="loader" class="w-4 h-4 mr-2 animate-spin"></i>
                                    Loading checkbox prompts...
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-4">
                                <button 
                                    onclick="loadTestData()"
                                    class="text-orange-600 hover:text-orange-800 text-sm font-medium transition-colors"
                                >
                                    📋 Load Sample Data
                                </button>
                                <button 
                                    onclick="clearCriteria()"
                                    class="text-gray-600 hover:text-gray-800 text-sm font-medium transition-colors"
                                >
                                    🗑️ Clear All
                                </button>
                            </div>
                            <div class="flex space-x-3">
                                <button id="testBtn" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-2 rounded-lg font-medium transition-colors flex items-center text-sm">
                                    <i data-lucide="flask" class="w-4 h-4 mr-2"></i>
                                    <span>🧪 Test Mode</span>
                                </button>
                                <button onclick="testTranscriptModal()" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 rounded-lg font-medium transition-colors flex items-center text-sm">
                                    <i data-lucide="eye" class="w-4 h-4 mr-2"></i>
                                    <span>📄 Test Modal</span>
                                </button>
                                <button onclick="testModalDirect()" class="bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded-lg font-medium transition-colors flex items-center text-sm">
                                    <i data-lucide="zap" class="w-4 h-4 mr-2"></i>
                                    <span>🔬 Direct Test</span>
                                </button>
                                <button
                                    onclick="saveCriteria()"
                                    class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-medium transition-colors"
                                >
                                    💾 Save & Apply
                                </button>
                            </div>
                        </div>

                        <div id="criteriaFeedback" class="hidden p-4 rounded-lg">
                            <!-- Feedback messages will appear here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Empty State -->
        <div id="emptyState" class="text-center py-16">
            <div class="w-24 h-24 mx-auto bg-gradient-to-br from-green-100 to-emerald-200 rounded-full flex items-center justify-center mb-6">
                <svg class="w-12 h-12 text-emerald-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z"/>
                </svg>
            </div>
            <h3 class="text-xl font-semibold text-gray-900 mb-2">Waiting for Students</h3>
            <p class="text-gray-600 max-w-md mx-auto">Student groups will appear here when they join your session. Set up your criteria above and start recording to begin.</p>
        </div>

        <!-- Groups Grid -->
        <div id="groupsGrid" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6 hidden">
            <!-- Group cards will be inserted here -->
        </div>
    </main>

    <!-- Create/Edit Checkbox Prompt Modal -->
    <div id="createCheckboxPromptModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full max-h-[90vh] overflow-hidden">
            <div class="flex items-center justify-between p-6 border-b border-gray-200">
                <div>
                    <h3 id="createCheckboxPromptModalTitle" class="text-lg font-semibold text-gray-900">Create New Checkbox Prompt</h3>
                    <p class="text-sm text-gray-600">Add a new checkbox prompt template to your library</p>
                </div>
                <button onclick="closeCreateCheckboxPromptModal()" class="text-gray-400 hover:text-gray-600 transition-colors">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <form id="createCheckboxPromptForm" class="p-6 overflow-y-auto max-h-[75vh]">
                <input type="hidden" id="editCheckboxPromptId" value="">
                
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="newCheckboxPromptTitle" class="block text-sm font-medium text-gray-700 mb-2">Title *</label>
                        <input 
                            type="text" 
                            id="newCheckboxPromptTitle" 
                            required
                            class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent text-sm"
                            placeholder="Enter prompt title..."
                        >
                </div>
                    <div>
                        <label for="newCheckboxPromptAuthor" class="block text-sm font-medium text-gray-700 mb-2">Author</label>
                        <input 
                            type="text" 
                            id="newCheckboxPromptAuthor" 
                            class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent text-sm"
                            placeholder="Your name (optional)"
                        >
            </div>
                    </div>

                <div class="mb-4">
                    <label for="newCheckboxPromptDescription" class="block text-sm font-medium text-gray-700 mb-2">Description</label>
                    <textarea 
                        id="newCheckboxPromptDescription" 
                        rows="2"
                        class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent resize-vertical text-sm"
                        placeholder="Describe this checkbox prompt template..."
                    ></textarea>
                </div>

                <div class="grid grid-cols-3 gap-4 mb-4">
                    <div>
                        <label for="newCheckboxPromptCategory" class="block text-sm font-medium text-gray-700 mb-2">Category</label>
                        <select id="newCheckboxPromptCategory" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent text-sm">
                            <option value="General">General</option>
                            <option value="Science">Science</option>
                            <option value="Mathematics">Mathematics</option>
                            <option value="Language Arts">Language Arts</option>
                            <option value="Social Studies">Social Studies</option>
                            <option value="Assessment">Assessment</option>
                            <option value="Discussion">Discussion</option>
                            <option value="Analysis">Analysis</option>
                        </select>
                    </div>
                    <div>
                        <label for="newCheckboxPromptVisibility" class="block text-sm font-medium text-gray-700 mb-2">Visibility</label>
                        <select id="newCheckboxPromptVisibility" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent text-sm">
                            <option value="true">Public</option>
                            <option value="false">Private</option>
                        </select>
                    </div>
                    <div class="flex items-end">
                        <input type="hidden" id="newCheckboxPromptMode" value="checkbox">
                        <div class="w-full px-3 py-2 bg-green-50 border border-green-200 rounded-lg text-sm text-green-700 font-medium text-center">
                            Checkbox Mode
                        </div>
                    </div>
                </div>

                <div class="mb-4">
                    <label for="newCheckboxPromptTags" class="block text-sm font-medium text-gray-700 mb-2">Tags</label>
                    <input 
                        type="text" 
                        id="newCheckboxPromptTags" 
                        class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent text-sm"
                        placeholder="Enter tags separated by commas"
                    >
                </div>

                <div class="mb-4">
                    <label for="newCheckboxPromptScenario" class="block text-sm font-medium text-gray-700 mb-2">Scenario/Question Template</label>
                    <textarea 
                        id="newCheckboxPromptScenario" 
                        rows="3"
                        class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent resize-vertical text-sm"
                        placeholder="Enter the discussion question or scenario template..."
                    ></textarea>
                </div>

                <div class="mb-6">
                    <label for="newCheckboxPromptContent" class="block text-sm font-medium text-gray-700 mb-2">Criteria Checklist *</label>
                    <textarea 
                        id="newCheckboxPromptContent" 
                        rows="6"
                        required
                        class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-transparent resize-vertical font-mono text-sm"
                        placeholder="Enter criteria checklist (one per line)..."
                    ></textarea>
                    <p class="text-xs text-gray-500 mt-1">Each line will become a separate checkbox criterion</p>
                </div>

                <div class="flex items-center justify-between pt-4 border-t border-gray-200">
                    <div class="text-sm text-gray-500">* Required fields</div>
                    <div class="flex space-x-3">
                        <button type="button" onclick="closeCreateCheckboxPromptModal()" class="px-4 py-2 border border-gray-300 rounded-lg text-gray-700 hover:bg-gray-50 transition-colors text-sm">
                            Cancel
                        </button>
                        <button type="submit" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg font-medium transition-colors text-sm">
                            <span id="createCheckboxPromptSubmitText">Create Prompt</span>
                    </button>
                </div>
            </div>
            </form>
        </div>
    </div>

    <script>
        // Global variables
        let socket = io(); // Initialize socket.io
        let sessionCode = null;
        let isRecording = false;
        let groups = new Map();
        let currentCriteria = [];
        let currentScenario = "";
        let currentStrictness = 2; // Default to moderate (1=lenient, 2=moderate, 3=strict)
        let criteriaSavedOnce = false; // Track if criteria were saved at least once
        let elapsedInterval = null;
        let recordingStart = null;
        
        // Update strictness label and description
        function updateStrictnessLabel(value) {
            const label = document.getElementById('strictnessLabel');
            const description = document.getElementById('strictnessDescription');
            currentStrictness = parseInt(value);
            
            switch(currentStrictness) {
                case 1:
                    label.textContent = 'Lenient';
                    label.className = 'text-sm font-medium text-green-600';
                    description.innerHTML = '<strong>Lenient:</strong> Accepts partial understanding and conceptual grasp. Good for open discussions.';
                    break;
                case 2:
                    label.textContent = 'Moderate';
                    label.className = 'text-sm font-medium text-blue-600';
                    description.innerHTML = '<strong>Moderate:</strong> Balanced evaluation requiring both concept and key details.';
                    break;
                case 3:
                    label.textContent = 'Strict';
                    label.className = 'text-sm font-medium text-red-600';
                    description.innerHTML = '<strong>Strict:</strong> Requires precise, complete answers with all rubric details. Best for assessments.';
                    break;
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            // Do NOT auto-load test data; only use teacher inputs or selected templates
            createSession(); // Create session automatically like admin.html
        });

        // Create new session automatically
        async function createSession() {
            try {
                const response = await fetch('/api/new-session');
                const data = await response.json();
                sessionCode = data.code;
                document.getElementById('sessionCode').textContent = sessionCode;
                socket.emit('admin_join', { code: sessionCode });
                console.log('📋 Checkbox mode session created:', sessionCode);
                
                // Clear any existing data to start fresh
                groups.clear();
                currentCriteria = [];
                currentScenario = "";
                
                // Automatically set up hardcoded criteria
                setupHardcodedCriteria();
                
                // Save criteria to backend if we have them
                if (currentCriteria.length > 0) {
                    console.log('📋 Auto-saving criteria to backend...');
                    await saveCriteriaToBackend();
                }
                
                // Load existing session data if available
                await loadExistingSessionData();
            } catch (err) {
                console.error('Failed to create session:', err);
                showError('Failed to create session. Please refresh the page.');
            }
        }

        // Helper function to save criteria to backend without UI feedback
        async function saveCriteriaToBackend() {
            try {
                // First cleanup any old data for this session
                await fetch(`/api/cleanup/${sessionCode}`, { method: 'POST' });
                
                const response = await fetch('/api/checkbox/session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionCode: sessionCode,
                        criteria: currentCriteria,
                        scenario: currentScenario || "Academic discussion session",
                        interval: parseInt(document.getElementById('intervalInput').value) * 1000,
                        strictness: currentStrictness // Add strictness level
                    })
                });

                if (response.ok) {
                    console.log('📋 Criteria auto-saved to backend:', currentCriteria.length, 'items with strictness:', currentStrictness);
                    criteriaSavedOnce = true;
                } else {
                    console.warn('📋 Failed to auto-save criteria:', response.status);
                }
            } catch (err) {
                console.warn('📋 Error auto-saving criteria:', err);
            }
        }

        // Load existing session data including checkbox progress
        async function loadExistingSessionData() {
            try {
                console.log('📋 Loading existing session data for:', sessionCode);
                
                const response = await fetch(`/api/checkbox/${sessionCode}`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('📋 Existing session data loaded:', data);
                    
                    if (data.success && data.criteriaWithProgress) {
                        // Update current criteria with existing progress
                        currentCriteria = data.criteriaWithProgress.map((item, index) => ({
                            id: index,
                            description: item.description,
                            completed: item.completed,
                            quote: item.quote || item.evidence
                        }));
                        
                        console.log('📋 Loaded existing criteria with progress:', currentCriteria.length, 'items');
                        
                        // If we have scenario data, update the UI
                        if (data.scenario) {
                            currentScenario = data.scenario;
                            document.getElementById('scenarioInput').value = data.scenario;
                        }
                        
                        // Update criteria input to show loaded criteria
                        const criteriaText = data.criteriaWithProgress.map(c => c.description).join('\n');
                        document.getElementById('criteriaInput').value = criteriaText;
                        
                        // Show feedback about loaded data
                        const completedCount = currentCriteria.filter(c => c.completed).length;
                        if (completedCount > 0) {
                            showFeedback(`✅ Loaded existing session with ${completedCount}/${currentCriteria.length} criteria already completed`, 'success');
                        }
                    }
                } else if (response.status === 404) {
                    console.log('📋 No existing checkbox session found - this is normal for new sessions');
                } else {
                    console.warn('📋 Failed to load existing session data:', response.status);
                }
            } catch (err) {
                console.warn('📋 Error loading existing session data (this is normal for new sessions):', err.message);
            }
        }

        // Setup hardcoded criteria automatically  
        function setupHardcodedCriteria() {
            const scenario = document.getElementById('scenarioInput').value.trim();
            const criteriaText = document.getElementById('criteriaInput').value.trim();
            
            if (criteriaText) {
                // Parse criteria with rubrics in parentheses format: "Description (Rubric)"
                const criteriaLines = criteriaText.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);

                currentCriteria = criteriaLines.map((line, index) => {
                    const trimmedLine = line.trim();
                    
                    // Extract description and rubric using regex
                    const match = trimmedLine.match(/^(.+?)\s*\((.+)\)\s*$/);
                    
                    if (match) {
                        // Format: "Description (Rubric)"
                        return {
                    id: index,
                            description: match[1].trim(),
                            rubric: match[2].trim(),
                            completed: false,
                            quote: null,
                            status: 'grey'
                        };
                    } else {
                        // Fallback: treat entire line as description
                        return {
                            id: index,
                            description: trimmedLine,
                            rubric: "No specific rubric provided",
                            completed: false,
                            quote: null,
                            status: 'grey'
                        };
                    }
                });
                currentScenario = scenario;
                
                console.log('📋 Hardcoded criteria ready:', currentCriteria.length, 'items with rubrics');
            }
        }

        // Load test data for quick setup
        function loadTestData() {
            const testCriteria = `Students explain that back titration is used (CaCO3 is not soluble in water and cannot be titrated directly)
Students identify that CaCO3 reacts with known volume of excess HCl (the volume of HCl used must be calculated to ensure that the titre volume is between 20 to 25 cm3)
Students identify the need to weigh by difference (there will be some CaCO3 left, so the weighing bottle must be reweighed)
Students recognise the need to cover the conical flask with a filter funnel (there is acid spray from the reaction between CaCO3 and HCl, cover to minimise loss of HCl)
Students understand that HCl must be diluted before titrating against NaOH (if not the titre volume will be more than 50 cm3, no longer between 20 to 25 cm3)
Students should choose the appropriate indicator (methyl orange or thymolphthalein)
Students recognise to stop titration after 2 consistent results (consistent to 0.10 cm3)`;
            
            const testScenario = "Chemistry Lab: Back Titration Analysis\nStudents are conducting a back titration experiment to determine the purity of calcium carbonate in an impure sample. They need to demonstrate understanding of the experimental procedure, safety considerations, and analytical techniques involved in this quantitative analysis method.";
            
            document.getElementById('criteriaInput').value = testCriteria;
            document.getElementById('scenarioInput').value = testScenario;
            
            console.log('📋 Loaded chemistry back titration test data');
        }

        // Toggle criteria editor
        function toggleCriteriaEditor() {
            const editor = document.getElementById('criteriaEditor');
            const chevron = document.getElementById('criteriaChevron');
            
            if (editor.classList.contains('hidden')) {
                editor.classList.remove('hidden');
                chevron.classList.add('rotate-180');
            } else {
                editor.classList.add('hidden');
                chevron.classList.remove('rotate-180');
            }
        }

        // Clear criteria
        function clearCriteria() {
            document.getElementById('scenarioInput').value = '';
            document.getElementById('criteriaInput').value = '';
            currentCriteria = [];
            currentScenario = "";
            showFeedback('Criteria cleared', 'info');
        }

        // Save and apply criteria
        async function saveCriteria() {
            const scenario = document.getElementById('scenarioInput').value.trim();
            const criteriaText = document.getElementById('criteriaInput').value.trim();
            
            if (!criteriaText) {
                showFeedback('Please enter at least one criterion', 'error');
                return;
            }

            // Parse criteria with rubrics in parentheses format: "Description (Rubric)"
            const criteriaLines = criteriaText.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);

            currentCriteria = criteriaLines.map((line, index) => {
                const trimmedLine = line.trim();
                
                // Extract description and rubric using regex
                const match = trimmedLine.match(/^(.+?)\s*\((.+)\)\s*$/);
                
                if (match) {
                    // Format: "Description (Rubric)"
                    return {
                id: index,
                        description: match[1].trim(),
                        rubric: match[2].trim(),
                        completed: false,
                        quote: null,
                        status: 'grey'
                    };
                } else {
                    // Fallback: treat entire line as description
                    return {
                        id: index,
                        description: trimmedLine,
                        rubric: "No specific rubric provided",
                        completed: false,
                        quote: null,
                        status: 'grey'
                    };
                }
            });
            currentScenario = scenario;

            // Update the display to show parsed criteria
            updateDisplay();

            // Save to backend
            try {
                const response = await fetch('/api/checkbox/session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionCode: sessionCode,
                        criteria: currentCriteria,
                        scenario: scenario,
                        interval: parseInt(document.getElementById('intervalInput').value) * 1000,
                        strictness: currentStrictness // Add strictness level
                    })
                });

                if (response.ok) {
                    showFeedback(`Criteria saved successfully! ${currentCriteria.length} criteria ready (Strictness: ${['', 'Lenient', 'Moderate', 'Strict'][currentStrictness]}).`, 'success');
                    console.log('📋 Criteria saved:', currentCriteria.length, 'items with rubrics, strictness:', currentStrictness);
                    criteriaSavedOnce = true;
                } else {
                    showFeedback('Failed to save criteria', 'error');
                }
            } catch (err) {
                console.error('Error saving criteria:', err);
                showFeedback('Error saving criteria', 'error');
            }
        }

        // Helper: build payload for fast Anthropic calls
        function getCurrentCheckboxConfig() {
            return {
                scenario: currentScenario || document.getElementById('scenarioInput').value.trim(),
                criteria: currentCriteria && currentCriteria.length > 0
                    ? currentCriteria.map(c => ({ description: c.description, rubric: c.rubric || '' }))
                    : (document.getElementById('criteriaInput').value.trim().split('\n')
                        .map(line => line.trim()).filter(Boolean).map((line) => {
                            const m = line.match(/^(.+?)\s*\((.+)\)\s*$/);
                            return m ? { description: m[1].trim(), rubric: m[2].trim() } : { description: line, rubric: '' };
                        }))
            };
        }

        // Show feedback message
        function showFeedback(message, type) {
            const feedback = document.getElementById('criteriaFeedback');
            const colors = {
                success: 'bg-green-50 border-green-200 text-green-800',
                error: 'bg-red-50 border-red-200 text-red-800',
                info: 'bg-blue-50 border-blue-200 text-blue-800'
            };
            
            feedback.className = `p-4 rounded-lg border ${colors[type]}`;
            feedback.textContent = message;
            feedback.classList.remove('hidden');
            
            if (type !== 'error') {
                setTimeout(() => {
                    feedback.classList.add('hidden');
                }, 3000);
            }
        }

        // Show error message
        function showError(message) {
            showFeedback(message, 'error');
        }

        // Update group with checkbox data
        function updateGroup(groupNumber, data) {
            // Hide empty state and show grid
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('groupsGrid').classList.remove('hidden');
            
            let groupEl = document.getElementById(`group-${groupNumber}`);
            if (!groupEl) {
                groupEl = document.createElement('div');
                groupEl.id = `group-${groupNumber}`;
                groupEl.className = 'animate-fade-in';
                document.getElementById('groupsGrid').appendChild(groupEl);
            }
            
            // Update group data - initialize with existing progress if available
            const groupData = groups.get(groupNumber) || {
                transcripts: [],
                checkboxes: currentCriteria.length > 0 ? currentCriteria.map(c => ({
                    id: c.id,
                    description: c.description,
                    rubric: c.rubric,
                    completed: c.completed || false,
                    quote: c.quote || null,
                    status: c.status || 'grey'
                })) : [], // Use currentCriteria if available, otherwise empty array
                stats: {}
            };
            
            // Handle new transcript data - improved handling
            if (data.latestTranscript) {
                console.log('📝 Adding transcript to group', groupNumber, ':', data.latestTranscript);
                
                // Check if this transcript is already added (avoid duplicates)
                const isDuplicate = groupData.transcripts.some(t => 
                    t.text === data.latestTranscript && 
                    Math.abs(t.timestamp - Date.now()) < 5000 // Within 5 seconds
                );
                
                if (!isDuplicate) {
                groupData.transcripts.push({
                    text: data.latestTranscript,
                        timestamp: Date.now(),
                        duration: data.transcriptDuration || 0,
                        wordCount: data.transcriptWordCount || 0
                    });
                    
                    // Keep reasonable number of transcripts (last 20)
                    if (groupData.transcripts.length > 20) {
                        groupData.transcripts = groupData.transcripts.slice(-20);
                    }
                    
                console.log('📚 Group', groupNumber, 'now has', groupData.transcripts.length, 'transcript segments');
            } else {
                    console.log('🔄 Skipping duplicate transcript for group', groupNumber);
                }
            }
            
            // Handle existing transcripts data (when loading from database)
            if (data.existingTranscripts && data.existingTranscripts.length > 0) {
                console.log('📂 Loading existing transcripts for group', groupNumber, ':', data.existingTranscripts.length, 'segments');
                groupData.transcripts = data.existingTranscripts;
            }

            // Handle checkbox updates from AI processing
            if (data.checkboxUpdates) {
                console.log('🔄 Processing', data.checkboxUpdates.length, 'checkbox updates');
                console.log('🔄 Current checkboxes before update:', groupData.checkboxes.map(c => ({id: c.id, completed: c.completed, status: c.status})));
                
                data.checkboxUpdates.forEach(update => {
                    console.log('🔄 Looking for checkbox with id:', update.criteriaId, 'in checkboxes:', groupData.checkboxes.map(c => c.id));
                    const checkbox = groupData.checkboxes.find(c => c.id === update.criteriaId);
                    if (checkbox) {
                        console.log('✅ Found checkbox, updating:', checkbox.id, 'to completed:', update.completed, 'status:', update.status);
                        // Only update if not already completed with correct status (preserve original correct answers)
                        if (!checkbox.completed || checkbox.status !== 'green') {
                        checkbox.completed = update.completed;
                        checkbox.quote = update.quote;
                            checkbox.status = update.status || 'grey'; // green, red, or grey
                        } else {
                            console.log('📋 Checkbox', checkbox.id, 'already completed correctly - preserving green status and quote:', checkbox.quote);
                        }
                    } else {
                        console.warn('❌ Could not find checkbox with id:', update.criteriaId);
                    }
                });
                
                console.log('🔄 Current checkboxes after update:', groupData.checkboxes.map(c => ({id: c.id, completed: c.completed, status: c.status})));
            }
            
            // Assign rebuilt, ordered, de-duplicated list
            groupData.checkboxes = (groupData.checkboxes || []).slice().sort((a, b) => Number(a.id) - Number(b.id));
            groups.set(data.groupNumber, groupData);
            
            // Update UI
            const completedCount = groupData.checkboxes.filter(c => c.completed).length;
            const totalCount = groupData.checkboxes.length;
            const completionRate = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;

            groupEl.innerHTML = `
                <div class="bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden transition-all duration-300 hover:shadow-xl">
                    <!-- Group Header -->
                    <div class="p-4 sm:p-6 bg-gray-600 text-white">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-3">
                                <div class="w-10 h-10 bg-white/20 rounded-full flex items-center justify-center font-bold text-lg">
                                    ${groupNumber}
                                </div>
                                <div>
                                    <h3 class="text-lg font-bold">Group ${groupNumber}</h3>
                                    <p class="text-sm opacity-90">${completedCount}/${totalCount} criteria completed</p>
                                </div>
                            </div>
                            <div class="flex items-center space-x-3">
                                 <button 
                                     onclick="releaseChecklistToGroup(${groupNumber})" 
                                     class="bg-white/20 hover:bg-white/30 text-white px-3 py-1 rounded-lg text-xs font-medium transition-colors flex items-center space-x-1"
                                     title="Send current checklist progress to students"
                                 >
                                     <i data-lucide="send" class="w-3 h-3"></i>
                                     <span>Release Checklist</span>
                                 </button>
                            </div>
                        </div>
                        <div class="mt-3">
                            <div class="flex items-center justify-between text-sm mb-2">
                                <span>Progress</span>
                                <span>${completionRate}%</span>
                            </div>
                            <div class="w-full bg-white/20 rounded-full h-2">
                                <div 
                                    class="bg-white h-2 rounded-full transition-all duration-300" 
                                    style="width: ${completionRate}%"
                                ></div>
                            </div>
                        </div>
                    </div>

                    <!-- Checkbox List -->
                    <div class="p-6">
                        <div class="space-y-3">
                            ${groupData.checkboxes.map((checkbox, index) => {
                                // Determine colors based on status
                                let bgColor, borderColor, checkColor, textColor;
                                switch(checkbox.status || 'grey') {
                                    case 'green':
                                        bgColor = 'bg-green-50';
                                        borderColor = 'border-green-200';
                                        checkColor = 'text-green-600';
                                        textColor = 'text-green-800';
                                        break;
                                    case 'red':
                                        bgColor = 'bg-red-50';
                                        borderColor = 'border-red-200';
                                        checkColor = 'text-red-600';
                                        textColor = 'text-red-800';
                                        break;
                                    default: // grey
                                        bgColor = 'bg-gray-50';
                                        borderColor = 'border-gray-200';
                                        checkColor = 'text-gray-400';
                                        textColor = 'text-gray-700';
                                }
                                
                                return `
                                    <div class="flex items-start space-x-3 p-3 ${bgColor} ${borderColor} border rounded-lg">
                                    <div class="flex-shrink-0 mt-1">
                                            ${checkbox.completed ? 
                                                `<i data-lucide="check-circle" class="w-5 h-5 ${checkColor}"></i>` : 
                                                `<i data-lucide="circle" class="w-5 h-5 ${checkColor}"></i>`
                                            }
                                    </div>
                                    <div class="flex-1 min-w-0">
                                            <div class="text-sm font-medium ${textColor} mb-1">
                                                ${checkbox.description}
                                            </div>
                                            <div class="text-xs text-gray-600 italic mb-2">
                                                Rubric: ${checkbox.rubric}
                                            </div>
                                            ${checkbox.quote ? `
                                                <div class="text-xs ${textColor} bg-white bg-opacity-50 rounded px-2 py-1 border-l-2 ${checkbox.status === 'green' ? 'border-green-400' : checkbox.status === 'red' ? 'border-red-400' : 'border-gray-400'}">
                                                "${checkbox.quote}"
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                                `;
                            }).join('')}
                        </div>
                        
                        ${groupData.transcripts.length > 0 ? `
                            <div class="mt-6 pt-4 border-t border-gray-100">
                                <div class="flex items-center justify-between mb-3">
                                    <h4 class="text-sm font-medium text-gray-700">Discussion Transcripts (${groupData.transcripts.length})</h4>
                                    <button onclick="toggleTranscripts(${groupNumber})" id="toggleTranscripts-${groupNumber}" class="text-xs text-blue-600 hover:text-blue-800 font-medium transition-colors flex items-center">
                                        <i data-lucide="chevron-down" class="w-3 h-3 mr-1"></i>
                                        Show All
                                    </button>
                                </div>
                                
                                <!-- Latest transcript preview -->
                                <div class="text-sm text-gray-600 bg-blue-50 border border-blue-200 rounded-lg p-3 mb-3">
                                    <div class="flex items-center justify-between mb-2">
                                        <span class="text-xs font-medium text-blue-700">Latest (${new Date(groupData.transcripts[groupData.transcripts.length - 1].timestamp).toLocaleTimeString()})</span>
                                        <span class="text-xs text-blue-600">Segment ${groupData.transcripts.length}</span>
                                    </div>
                                    <div class="text-gray-800 whitespace-pre-wrap break-words">
                                        ${groupData.transcripts[groupData.transcripts.length - 1].text}
                                    </div>
                                </div>
                                
                                <!-- All transcripts (collapsible) -->
                                <div id="allTranscripts-${groupNumber}" class="hidden space-y-2">
                                    ${groupData.transcripts.slice(0, -1).reverse().map((transcript, index) => `
                                        <div class="text-sm bg-gray-50 border border-gray-200 rounded-lg p-3">
                                            <div class="flex items-center justify-between mb-2">
                                                <span class="text-xs font-medium text-gray-600">
                                                    ${new Date(transcript.timestamp).toLocaleTimeString()}
                                                </span>
                                                <span class="text-xs text-gray-500">
                                                    Segment ${groupData.transcripts.length - 1 - index}
                                                </span>
                                            </div>
                                            <div class="text-gray-800 whitespace-pre-wrap break-words">
                                                ${transcript.text}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;

            // Re-initialize Lucide icons
            lucide.createIcons();
        }

        // Socket event handlers (similar to admin.html)
        socket.on('student_joined', ({ group, socketId }) => {
            console.log(`✅ Student joined group ${group}`);
            updateGroup(group, { isActive: true });
            
            // Fetch existing transcript data for this group
            fetch(`/api/transcripts/${sessionCode}/${group}`)
                .then(async res => {
                    if (!res.ok) return { transcripts: [], summary: null, stats: {} };
                    return res.json();
                })
                .then(data => {
                    console.log('📂 Fetched existing data for group', group, ':', data);
                    
                    // Format existing transcripts with proper structure
                    const formattedTranscripts = data.transcripts.map(t => ({
                        text: t.text,
                        timestamp: new Date(t.created_at).getTime(),
                        duration: t.duration_seconds || 0,
                        wordCount: t.word_count || 0
                    }));
                    
                    console.log('📂 Formatted', formattedTranscripts.length, 'existing transcripts for group', group);
                    
                    updateGroup(group, {
                        existingTranscripts: formattedTranscripts,
                        stats: data.stats,
                        isActive: true
                    });
                })
                .catch(err => {
                    console.error('Failed to fetch group data:', err);
                    updateGroup(group, { 
                        isActive: true, 
                        uploadError: 'Failed to load existing data' 
                    });
                });
        });

        // ===== Heartbeat support (admin-side for checkbox dashboard) =====
        function startHeartbeat() {
            // Send heartbeat every 10 seconds
            heartbeatInterval = setInterval(() => {
                if (socket.connected && sessionCode) {
                    socket.emit('admin_heartbeat', { sessionCode });
                    console.log('💓 Admin heartbeat sent (checkbox)');
                }
            }, 10000);
            
            // Check connection status every 3 seconds with 25s tolerance
            connectionCheckInterval = setInterval(() => {
                const now = Date.now();
                const timeSinceLastHeartbeat = now - lastHeartbeatTime;
                if (timeSinceLastHeartbeat > 25000) {
                    updateConnectionStatus(false);
                } else {
                    updateConnectionStatus(true);
                }
            }, 3000);
        }
        // Start heartbeats on load
        document.addEventListener('DOMContentLoaded', () => {
            startHeartbeat();
        });

        // Listen for checklist state updates (includes real-time progress)
        socket.on('checklist_state', (data) => {
            console.log('📋 Received checklist state update for group', data.groupNumber);
            console.log('📋 Criteria updates:', data.criteria?.length || 0, 'items');
            
            // Get existing group data or create new
            const groupData = groups.get(data.groupNumber) || {
                transcripts: [],
                checkboxes: [],
                stats: {},
                isActive: false
            };
            
            // Build a map of existing checkboxes by id for quick lookup
            const existingById = new Map((groupData.checkboxes || []).map(c => [c.id, c]));
            
            // Use the server's criteria array as the source of truth for order
            const incoming = Array.isArray(data.criteria) ? [...data.criteria] : [];
            // Ensure stable order by id (in case backend sends unsorted)
            incoming.sort((a, b) => Number(a.id) - Number(b.id));
            
            // Rebuild the checkbox list to avoid duplicates and preserve order
            const merged = incoming.map(item => {
                const id = Number(item.id);
                const dbId = item.dbId;
                const prev = existingById.get(id);
                if (prev && prev.status === 'green' && item.status !== 'green') {
                    // Preserve GREEN status and quote from previous state
                    return {
                        ...item,
                        id,
                        dbId,
                        status: 'green',
                        completed: true,
                        quote: prev.quote
                    };
                }
                // Otherwise, trust the server-provided state
                return { ...item, id, dbId };
            });
            
            // Assign rebuilt, ordered, de-duplicated list
            groupData.checkboxes = merged.sort((a, b) => Number(a.id) - Number(b.id));
            groups.set(data.groupNumber, groupData);
            
            // Re-render the group display with the merged data
            updateGroup(data.groupNumber, {
                checkboxUpdates: groupData.checkboxes.map(c => ({
                    criteriaId: c.id,
                    completed: c.completed,
                    quote: c.quote,
                    status: c.status
                }))
            });
        });

        socket.on('admin_update', (data) => {
            console.log('📋 Received checkbox update:', data);
            console.log('📋 Update for group:', data.group);
            console.log('📋 Latest transcript:', data.latestTranscript ? data.latestTranscript : 'None');
            console.log('📋 Checkbox updates received:', data.checkboxUpdates);
            
            // Ensure we always pass transcript data to updateGroup
            const groupData = groups.get(data.group) || { transcripts: [], checkboxes: [] };
            const byDbId = new Map(groupData.checkboxes.map(c => [c.dbId, c]));
            const byIndex = new Map(groupData.checkboxes.map(c => [c.id, c]));
            const safeUpdates = (data.checkboxUpdates || []).map(u => {
                const target = (u.criteriaDbId && byDbId.get(u.criteriaDbId)) || byIndex.get(u.criteriaId);
                if (!target) return u; // fallback
                return { ...u, criteriaId: target.id };
            });
            updateGroup(data.group, {
                latestTranscript: data.latestTranscript,
                checkboxUpdates: safeUpdates,
                isActive: true
            });
        });

        socket.on('connect', () => {
            console.log('🔌 Checkbox admin connected');
            if (sessionCode) {
                socket.emit('admin_join', { code: sessionCode });
            }
        });

        // Recording controls (improved responsiveness)
        document.getElementById('startBtn').addEventListener('click', async () => {
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const intervalInput = document.getElementById('intervalInput');
            
            // Prevent multiple clicks
            if (startBtn.disabled || isRecording) {
                console.log('🚫 Start button already processing or recording active');
                return;
            }
            
            // Immediate UI feedback - disable button and show loading
            startBtn.disabled = true;
            startBtn.innerHTML = `
                <svg class="animate-spin w-4 h-4 sm:w-5 sm:h-5 mr-2" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span class="hidden sm:inline">Starting...</span>
                <span class="sm:hidden">...</span>
            `;
            startBtn.classList.add('opacity-75', 'cursor-not-allowed');
            
            try {
                console.log('🎬 Start Recording button clicked');
                
                // Step 1: Ensure criteria are loaded, but don't block recording start
                showFeedback('📋 Preparing criteria...', 'info');
                if (currentCriteria.length === 0) {
                    console.log('📋 No criteria found. Will start recording immediately and save criteria when available.');
                } else {
                    console.log('📋 Using criteria:', currentCriteria.length, 'items');
                }

                // Step 2: Start the recording session IMMEDIATELY (no waiting on criteria save)
                showFeedback('▶️ Starting recording session...', 'info');
                console.log('▶️ Starting recording session...');
                const intervalSeconds = parseInt(intervalInput.value) || 30;
                const intervalMs = intervalSeconds * 1000;
                
                const response = await fetch(`/api/session/${sessionCode}/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interval: intervalMs })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Start session failed:', response.status, errorText);
                    throw new Error(`Failed to start recording: HTTP ${response.status}`);
                }
                
                console.log('✅ Recording session started successfully');
                
                // Update UI for recording state immediately
                startBtn.innerHTML = `
                    <i data-lucide="mic" class="w-4 h-4 sm:w-5 sm:h-5 mr-2"></i>
                    <span class="hidden sm:inline">Recording...</span>
                    <span class="sm:hidden">Rec</span>
                `;
                startBtn.classList.add('opacity-75', 'cursor-not-allowed');
                stopBtn.disabled = false;
                stopBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                intervalInput.disabled = true;

                // Start elapsed timer
                recordingStart = Date.now();
                if (elapsedInterval) {
                    clearInterval(elapsedInterval);
                }
                elapsedInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - recordingStart) / 1000);
                    const m = Math.floor(elapsed / 60);
                    const s = elapsed % 60;
                    document.getElementById('timeElapsed').textContent = `${m}:${s.toString().padStart(2,'0')}`;
                }, 1000);

                isRecording = true;
                showFeedback(`✅ Recording started! Session: ${sessionCode} | ${currentCriteria.length} criteria active | Students can now join and discuss.`, 'success');
                
                // Step 3: Save criteria IN THE BACKGROUND so start feels instant
                if (!criteriaSavedOnce && currentCriteria.length > 0) {
                    (async () => {
                        try {
                            console.log('💾 Saving criteria to backend (background)...');
                            const bgRes = await fetch('/api/checkbox/session', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    sessionCode: sessionCode,
                                    criteria: currentCriteria,
                                    scenario: currentScenario || 'Chemistry discussion session',
                                    interval: intervalMs,
                                    strictness: currentStrictness
                                })
                            });
                            if (bgRes.ok) {
                                criteriaSavedOnce = true;
                                console.log('✅ Criteria saved (background)');
                            } else {
                                const text = await bgRes.text();
                                console.warn('⚠️ Criteria save failed (background):', text);
                            }
                        } catch (e) {
                            console.warn('⚠️ Criteria background save error:', e);
                        }
                    })();
                }

                // Re-create icons after updating button HTML
                lucide.createIcons();
                
            } catch (err) {
                console.error('❌ Failed to start session:', err);
                showError(`Failed to start recording: ${err.message}`);
                
                // Reset UI on error
                startBtn.disabled = false;
                startBtn.innerHTML = `
                    <i data-lucide="play" class="w-4 h-4 sm:w-5 sm:h-5 mr-2"></i>
                    <span class="hidden sm:inline">Start Recording</span>
                    <span class="sm:hidden">Start</span>
                `;
                startBtn.classList.remove('opacity-75', 'opacity-75', 'cursor-not-allowed');
                stopBtn.disabled = true;
                stopBtn.classList.add('opacity-50', 'cursor-not-allowed');
                intervalInput.disabled = false;
                isRecording = false;
                
                // Re-create icons after resetting button HTML
                lucide.createIcons();
            }
        });
        
        document.getElementById('stopBtn').addEventListener('click', async () => {
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const intervalInput = document.getElementById('intervalInput');
            
            // Prevent multiple clicks
            if (stopBtn.disabled || !isRecording) {
                console.log('🚫 Stop button already processing or not recording');
                return;
            }
            
            // Immediate UI feedback
            stopBtn.disabled = true;
            stopBtn.innerHTML = `
                <svg class="animate-spin w-4 h-4 sm:w-5 sm:h-5 mr-2" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span class="hidden sm:inline">Stopping...</span>
                <span class="sm:hidden">...</span>
            `;
            stopBtn.classList.add('opacity-75');
            
            try {
                showFeedback('⏹️ Stopping recording...', 'info');
                
                const response = await fetch(`/api/session/${sessionCode}/stop`, { method: 'POST' });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                // Update UI for stopped state
                startBtn.disabled = false;
                startBtn.classList.remove('opacity-75');
                
                stopBtn.innerHTML = `
                    <i data-lucide="square" class="w-4 h-4 sm:w-5 sm:h-5 mr-2"></i>
                    <span class="hidden sm:inline">Stop Recording</span>
                    <span class="sm:hidden">Stop</span>
                `;
                stopBtn.classList.add('opacity-50', 'cursor-not-allowed');
                stopBtn.classList.remove('opacity-75');
                
                intervalInput.disabled = false;

                // Stop elapsed timer
                if (elapsedInterval) {
                    clearInterval(elapsedInterval);
                    elapsedInterval = null;
                }
                document.getElementById('timeElapsed').textContent = '0:00';
                isRecording = false;
                
                showFeedback('⏹️ Recording stopped successfully!', 'success');
                
                // Re-create icons after updating button HTML
                lucide.createIcons();
                
            } catch (err) {
                console.error('❌ Failed to stop session:', err);
                showError(`Failed to stop recording: ${err.message}`);
                
                // Reset stop button on error (keep recording state)
                stopBtn.disabled = false;
                stopBtn.innerHTML = `
                    <i data-lucide="square" class="w-4 h-4 sm:w-5 sm:h-5 mr-2"></i>
                    <span class="hidden sm:inline">Stop Recording</span>
                    <span class="sm:hidden">Stop</span>
                `;
                stopBtn.classList.remove('opacity-50', 'opacity-75', 'cursor-not-allowed');
                
                // Re-create icons after resetting button HTML
                lucide.createIcons();
            }
        });

        // Direct modal test function - bypasses all data checks
        window.testModalDirect = function() {
            console.log('🔬 Direct modal test - bypassing all data checks');
            
            const modalEl = document.getElementById('transcriptModal');
            const groupNumEl = document.getElementById('modalGroupNumber');
            const countEl = document.getElementById('modalTranscriptCount');
            const contentEl = document.getElementById('modalTranscriptContent');
            
            if (!modalEl) {
                console.error('❌ transcriptModal element not found');
                alert('ERROR: transcriptModal element not found');
                return;
            }
            
            if (!groupNumEl) {
                console.error('❌ modalGroupNumber element not found');
                alert('ERROR: modalGroupNumber element not found');
                return;
            }
            
            if (!countEl) {
                console.error('❌ modalTranscriptCount element not found');
                alert('ERROR: modalTranscriptCount element not found');
                return;
            }
            
            if (!contentEl) {
                console.error('❌ modalTranscriptContent element not found');
                alert('ERROR: modalTranscriptContent element not found');
                return;
            }
            
            // Set test content directly
            groupNumEl.textContent = '1';
            countEl.textContent = '3';
            contentEl.innerHTML = `
                <div class="border border-gray-200 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-medium text-gray-700">Segment 1</span>
                        <span class="text-xs text-gray-500">10:30:15</span>
                    </div>
                    <div class="text-sm text-gray-900 leading-relaxed">
                        Test transcript segment 1 - This is a test to see if the modal opens correctly.
                    </div>
                </div>
                <div class="border border-gray-200 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-medium text-gray-700">Segment 2</span>
                        <span class="text-xs text-gray-500">10:31:20</span>
                    </div>
                    <div class="text-sm text-gray-900 leading-relaxed">
                        Test transcript segment 2 - This should appear in the modal if it's working.
                    </div>
                </div>
                <div class="border border-gray-200 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-medium text-gray-700">Segment 3</span>
                        <span class="text-xs text-gray-500">10:32:25</span>
                    </div>
                    <div class="text-sm text-gray-900 leading-relaxed">
                        Test transcript segment 3 - If you can see this, the modal is working!
                    </div>
                </div>
            `;
            
            console.log('✅ All modal elements found, attempting to show modal');
            modalEl.classList.remove('hidden');
            console.log('✅ Modal should now be visible');
            
            // Test if modal is actually visible
            const isVisible = !modalEl.classList.contains('hidden');
            console.log('🔍 Modal visibility check:', isVisible);
            
            if (isVisible) {
                alert('SUCCESS: Modal opened successfully! You should see the transcript modal.');
            } else {
                alert('ERROR: Modal should be visible but might not be showing up.');
            }
        };

        // Test function to verify transcript modal functionality
        window.testTranscriptModal = function() {
            console.log('🧪 Testing transcript modal functionality...');
            
            // Create mock transcript data for Group 1
            const testTranscripts = [
                {
                    text: "Students explain that back titration is used because CaCO₃ is not soluble in water and cannot be titrated directly.",
                    timestamp: Date.now() - 300000 // 5 minutes ago
                },
                {
                    text: "Right, CaCO₃ reacts with HCl to form salt, water, and carbon dioxide. You can see the effervescence from the CO₂ being released.",
                    timestamp: Date.now() - 240000 // 4 minutes ago
                },
                {
                    text: "We should use a weighing bottle and analytical balance for accuracy. Yes, and we use the weighing by difference technique.",
                    timestamp: Date.now() - 180000 // 3 minutes ago
                },
                {
                    text: "For the titration part, we want our titre volume to be between 20 and 25 cm³ to minimize percentage error.",
                    timestamp: Date.now() - 120000 // 2 minutes ago
                },
                {
                    text: "We'll use methyl orange as our indicator. Methyl orange changes from red to orange at the endpoint.",
                    timestamp: Date.now() - 60000 // 1 minute ago
                }
            ];
            
            // Ensure Group 1 exists
            if (!groups.has(1)) {
                updateGroup(1, { isActive: true });
            }
            
            // Add test transcripts to Group 1
            const groupData = groups.get(1);
            groupData.transcripts = testTranscripts;
            groups.set(1, groupData);
            
            // Update the UI to show the group
            updateGroup(1, { 
                isActive: true,
                latestTranscript: testTranscripts[testTranscripts.length - 1].text
            });
            
            console.log('✅ Added', testTranscripts.length, 'test transcripts to Group 1');
            showFeedback(`✅ Test data added! Group 1 now has ${testTranscripts.length} transcript segments. Try the "View Full Transcript" button.`, 'success');
        };

        // Test button functionality
        document.getElementById('testBtn').addEventListener('click', async () => {
            try {
                const testTranscript = `So for this back titration, we need to understand why we can't just titrate calcium carbonate directly, right? Yeah, that's because CaCO₃ is not soluble in water. You can't titrate something that doesn't dissolve properly. Exactly! Direct titration is not suitable for insoluble solids like calcium carbonate. That's why we need to use back titration. So we add hydrochloric acid to react with the CaCO₃ first? Right, CaCO₃ reacts with HCl to form salt, water, and carbon dioxide. You can see the effervescence from the CO₂ being released. And we need to add excess HCl to make sure all the calcium carbonate reacts completely. Then we use NaOH to determine how much unreacted HCl is left. I remember we need to be careful with the weighing. We should use a weighing bottle and analytical balance for accuracy. Yes, and we use the weighing by difference technique—weigh the full bottle first, then weigh it again after transferring some powder. Some residue always remains. For the titration part, we want our titre volume to be between 20 and 25 cm³ to minimize percentage error. And we'll use methyl orange as our indicator. Methyl orange changes from red to orange at the endpoint, right? We stop when we get consistent titres with a permanent colour change. Don't forget we need to dilute the solution before titration because the HCl is more concentrated than the NaOH we're using.`;
                
                console.log('🧪 Starting test mode...');
                
                // First ensure we have criteria saved
                if (currentCriteria.length === 0) {
                    setupHardcodedCriteria();
                }
                
                if (currentCriteria.length === 0) {
                    showError('No criteria available. Please refresh the page.');
                    return;
                }
                
                // Save criteria to backend if not already done
                console.log('🧪 Saving criteria for test...');
                const criteriaResponse = await fetch('/api/checkbox/session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionCode: sessionCode,
                        scenario: currentScenario,
                        criteria: currentCriteria,
                        interval: 30000
                    })
                });
                
                if (!criteriaResponse.ok) {
                    const errorData = await criteriaResponse.json();
                    console.warn('🧪 Criteria save warning (may be duplicate):', errorData.error);
                    // Continue anyway - might be duplicate key error which is OK
                }
                
                // Create a test group if it doesn't exist
                if (!groups.has(1)) {
                    updateGroup(1, { isActive: true });
                }
                
                // Process the test transcript using dedicated test endpoint
                console.log('🧪 Processing test transcript...');
                const processResponse = await fetch('/api/checkbox/test', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionCode: sessionCode,
                        transcript: testTranscript
                    })
                });
                
                if (!processResponse.ok) {
                    const errorText = await processResponse.text();
                    throw new Error(`HTTP ${processResponse.status}: ${errorText}`);
                }
                
                const result = await processResponse.json();
                console.log('🧪 Test result:', result);
                
                // Ensure result.matches is always an array
                const matches = Array.isArray(result.matches) ? result.matches : [];
                console.log('🧪 Matches found:', matches.length);
                
                // Update the group with the test results
                const checkboxUpdates = matches.map(match => ({
                    criteriaId: match.criteria_index,
                    completed: true,
                    quote: match.quote
                }));
                
                updateGroup(1, {
                    latestTranscript: testTranscript,
                    checkboxUpdates: checkboxUpdates,
                    isActive: true
                });
                
                showFeedback(`🧪 Test completed! ${matches.length} criteria matched from ${currentCriteria.length} total.`, 'success');
                
            } catch (err) {
                console.error('🧪 Test failed:', err);
                showError(`Test failed: ${err.message}`);
            }
        });

        // Toggle transcripts display (replaces modal)
        function toggleTranscripts(groupNumber) {
            const allTranscriptsDiv = document.getElementById(`allTranscripts-${groupNumber}`);
            const toggleButton = document.getElementById(`toggleTranscripts-${groupNumber}`);
            
            if (allTranscriptsDiv.classList.contains('hidden')) {
                // Show all transcripts
                allTranscriptsDiv.classList.remove('hidden');
                toggleButton.innerHTML = `
                    <i data-lucide="chevron-up" class="w-3 h-3 mr-1"></i>
                    Hide All
                `;
            } else {
                // Hide all transcripts
                allTranscriptsDiv.classList.add('hidden');
                toggleButton.innerHTML = `
                    <i data-lucide="chevron-down" class="w-3 h-3 mr-1"></i>
                    Show All
                `;
            }
            
            // Re-initialize icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // Initialize checkbox prompt library on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadCheckboxPromptLibrary();
        });
        
        // ===================
        // CHECKBOX PROMPT MANAGEMENT
        // ===================
        
        let currentCheckboxPrompts = [];
        let availableCheckboxCategories = [];
        
        // Load checkbox prompt library from API
        async function loadCheckboxPromptLibrary() {
            try {
                const response = await fetch('/api/prompts?mode=checkbox&limit=50');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                currentCheckboxPrompts = data.prompts;
                availableCheckboxCategories = data.filters.categories;
                
                updateCheckboxCategoryFilter();
                displayCheckboxPromptLibrary(data.prompts);
                
            } catch (err) {
                console.error('❌ Failed to load checkbox prompt library:', err);
                document.getElementById('checkboxPromptLibraryGrid').innerHTML = `
                    <div class="flex items-center justify-center py-8 text-red-500 text-sm col-span-full">
                        <i data-lucide="alert-circle" class="w-4 h-4 mr-2"></i>
                        Failed to load prompts: ${err.message}
                    </div>
                `;
                lucide.createIcons();
            }
        }
        
        // Refresh checkbox prompt library
        function refreshCheckboxPrompts() {
            document.getElementById('checkboxPromptLibraryGrid').innerHTML = `
                <div class="flex items-center justify-center py-8 text-gray-500 text-sm col-span-full">
                    <i data-lucide="loader" class="w-4 h-4 mr-2 animate-spin"></i>
                    Refreshing prompts...
                </div>
            `;
            lucide.createIcons();
            loadCheckboxPromptLibrary();
        }
        
        // Update checkbox category filter options
        function updateCheckboxCategoryFilter() {
            const categoryFilter = document.getElementById('checkboxPromptCategoryFilter');
            const currentValue = categoryFilter.value;
            
            // Clear existing options (except "All Categories")
            while (categoryFilter.children.length > 1) {
                categoryFilter.removeChild(categoryFilter.lastChild);
            }
            
            // Add category options
            availableCheckboxCategories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            });
            
            // Restore selection
            categoryFilter.value = currentValue;
        }
        
        // Display checkbox prompt library
        function displayCheckboxPromptLibrary(prompts) {
            const grid = document.getElementById('checkboxPromptLibraryGrid');
            
            if (prompts.length === 0) {
                grid.innerHTML = `
                    <div class="flex items-center justify-center py-8 text-gray-500 text-sm col-span-full">
                        <i data-lucide="file-text" class="w-4 h-4 mr-2"></i>
                        No checkbox prompts found
                    </div>
                `;
                lucide.createIcons();
                    return;
                }
                
            const promptsHtml = prompts.map(prompt => {
                // Parse the prompt content to get scenario and criteria
                const lines = prompt.content.split('\n').filter(line => line.trim());
                const isScenarioHeader = lines.length > 0 && /^\s*scenario\s*:/i.test(lines[0]);
                const criteriaCount = isScenarioHeader ? Math.max(0, lines.length - 1) : lines.length;
                
                    return `
                    <div class="bg-gray-50 rounded-lg p-3 hover:bg-gray-100 transition-colors cursor-pointer border border-gray-200" onclick="loadCheckboxPrompt('${prompt._id}')">
                        <div class="flex items-start justify-between mb-2">
                            <h5 class="text-sm font-medium text-gray-900 truncate flex-1 mr-2">${prompt.title}</h5>
                            <div class="flex items-center space-x-1 flex-shrink-0">
                                ${prompt.isPublic ? '<i data-lucide="globe" class="w-3 h-3 text-green-500" title="Public"></i>' : '<i data-lucide="lock" class="w-3 h-3 text-gray-400" title="Private"></i>'}
                                <button onclick="event.stopPropagation(); editCheckboxPrompt('${prompt._id}')" class="text-blue-500 hover:text-blue-700" title="Edit">
                                    <i data-lucide="edit" class="w-3 h-3"></i>
                                </button>
                                <button onclick="event.stopPropagation(); deleteCheckboxPrompt('${prompt._id}')" class="text-red-500 hover:text-red-700" title="Delete">
                                    <i data-lucide="trash-2" class="w-3 h-3"></i>
                                </button>
                            </div>
                        </div>
                        <p class="text-xs text-gray-600 mb-2 line-clamp-2">${prompt.description || 'No description'}</p>
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-gray-200 text-gray-800">
                                    ${prompt.category}
                                </span>
                                <span class="text-xs text-gray-500">${criteriaCount} criteria</span>
                            </div>
                            <div class="text-xs text-gray-500">
                                ${prompt.usage_count || 0} uses
                            </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
            grid.innerHTML = promptsHtml;
            lucide.createIcons();
        }
        
        // Filter checkbox prompts
        function filterCheckboxPrompts() {
            const search = document.getElementById('checkboxPromptSearch').value.toLowerCase();
            const category = document.getElementById('checkboxPromptCategoryFilter').value;
            
            let filteredPrompts = currentCheckboxPrompts.filter(prompt => {
                const matchesSearch = !search || 
                    prompt.title.toLowerCase().includes(search) ||
                    (prompt.description && prompt.description.toLowerCase().includes(search)) ||
                    prompt.content.toLowerCase().includes(search) ||
                    (prompt.tags && prompt.tags.some(tag => tag.toLowerCase().includes(search)));
                
                const matchesCategory = !category || prompt.category === category;
                
                return matchesSearch && matchesCategory;
            });
            
            displayCheckboxPromptLibrary(filteredPrompts);
        }
        
        // Load a checkbox prompt into the current editor
        async function loadCheckboxPrompt(promptId) {
            try {
                const response = await fetch(`/api/prompts/${promptId}/use`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionCode: sessionCode || 'web-interface' })
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                const prompt = data.prompt;
                
                // Parse the content to separate scenario and criteria
                const lines = prompt.content.split('\n').filter(line => line.trim());
                
                // Extract scenario from first line if formatted as "Scenario: ..."
                let scenario = '';
                let criteria = [];
                if (lines.length > 0 && /^\s*scenario\s*:/i.test(lines[0])) {
                    scenario = lines[0].replace(/^\s*scenario\s*:\s*/i, '').trim();
                    criteria = lines.slice(1);
                } else {
                    // Fallbacks
                    if (prompt.scenario && typeof prompt.scenario === 'string') {
                        scenario = prompt.scenario.trim();
                        criteria = lines;
                    } else {
                        criteria = lines; // legacy prompts: all lines are criteria
                    }
                }
                
                // Load into the form
                document.getElementById('scenarioInput').value = scenario;
                document.getElementById('criteriaInput').value = criteria.join('\n');
                
                showCriteriaFeedback(`✅ Loaded checkbox prompt: "${prompt.title}"`, 'success');
                
            } catch (err) {
                console.error('❌ Failed to load checkbox prompt:', err);
                showCriteriaFeedback(`❌ Failed to load prompt: ${err.message}`, 'error');
            }
        }
        
        // Open create checkbox prompt modal
        function openCreateCheckboxPromptModal() {
            document.getElementById('createCheckboxPromptModalTitle').textContent = 'Create New Checkbox Prompt';
            document.getElementById('createCheckboxPromptSubmitText').textContent = 'Create Prompt';
            document.getElementById('createCheckboxPromptForm').reset();
            document.getElementById('editCheckboxPromptId').value = '';
            document.getElementById('newCheckboxPromptMode').value = 'checkbox';
            
            // Pre-fill with current form data if available
            const currentScenario = document.getElementById('scenarioInput').value;
            const currentCriteria = document.getElementById('criteriaInput').value;
            
            if (currentScenario) {
                document.getElementById('newCheckboxPromptScenario').value = currentScenario;
            }
            if (currentCriteria) {
                document.getElementById('newCheckboxPromptContent').value = currentCriteria;
            }
            
            document.getElementById('createCheckboxPromptModal').classList.remove('hidden');
        }
        
        // Close create checkbox prompt modal
        function closeCreateCheckboxPromptModal() {
            document.getElementById('createCheckboxPromptModal').classList.add('hidden');
        }
        
        // Edit checkbox prompt
        async function editCheckboxPrompt(promptId) {
            try {
                const response = await fetch(`/api/prompts/${promptId}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                const prompt = data.prompt;
                
                document.getElementById('createCheckboxPromptModalTitle').textContent = 'Edit Checkbox Prompt';
                document.getElementById('createCheckboxPromptSubmitText').textContent = 'Update Prompt';
                document.getElementById('editCheckboxPromptId').value = prompt._id;
                document.getElementById('newCheckboxPromptTitle').value = prompt.title;
                document.getElementById('newCheckboxPromptDescription').value = prompt.description || '';
                document.getElementById('newCheckboxPromptContent').value = prompt.content;
                document.getElementById('newCheckboxPromptScenario').value = prompt.scenario || '';
                document.getElementById('newCheckboxPromptCategory').value = prompt.category;
                document.getElementById('newCheckboxPromptTags').value = prompt.tags ? prompt.tags.join(', ') : '';
                document.getElementById('newCheckboxPromptVisibility').value = prompt.isPublic.toString();
                document.getElementById('newCheckboxPromptAuthor').value = prompt.authorName || '';
                document.getElementById('newCheckboxPromptMode').value = prompt.mode;
                
                document.getElementById('createCheckboxPromptModal').classList.remove('hidden');
                
            } catch (err) {
                console.error('❌ Failed to load checkbox prompt for editing:', err);
                alert(`Failed to load prompt: ${err.message}`);
            }
        }
        
        // Delete checkbox prompt
        async function deleteCheckboxPrompt(promptId) {
            const prompt = currentCheckboxPrompts.find(p => p._id === promptId);
            if (!prompt) return;
            
            if (!confirm(`Are you sure you want to delete "${prompt.title}"? This action cannot be undone.`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/prompts/${promptId}`, { method: 'DELETE' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                showCriteriaFeedback(`✅ Deleted checkbox prompt: "${prompt.title}"`, 'success');
                refreshCheckboxPrompts();
                
            } catch (err) {
                console.error('❌ Failed to delete checkbox prompt:', err);
                showCriteriaFeedback(`❌ Failed to delete prompt: ${err.message}`, 'error');
            }
        }
        
        // Handle create/edit checkbox prompt form submission
        async function handleCreateCheckboxPromptSubmit(e) {
            e.preventDefault();
            
            const promptId = document.getElementById('editCheckboxPromptId').value;
            const isEdit = Boolean(promptId);
            
            const formData = {
                title: document.getElementById('newCheckboxPromptTitle').value,
                description: document.getElementById('newCheckboxPromptDescription').value,
                content: document.getElementById('newCheckboxPromptContent').value,
                scenario: document.getElementById('newCheckboxPromptScenario').value,
                category: document.getElementById('newCheckboxPromptCategory').value,
                mode: document.getElementById('newCheckboxPromptMode').value,
                tags: document.getElementById('newCheckboxPromptTags').value.split(',').map(tag => tag.trim()).filter(tag => tag),
                isPublic: document.getElementById('newCheckboxPromptVisibility').value === 'true',
                authorName: document.getElementById('newCheckboxPromptAuthor').value
            };
            
            try {
                const url = isEdit ? `/api/prompts/${promptId}` : '/api/prompts';
                const method = isEdit ? 'PUT' : 'POST';
                
                const response = await fetch(url, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                
                showCriteriaFeedback(`✅ ${isEdit ? 'Updated' : 'Created'} checkbox prompt: "${formData.title}"`, 'success');
                closeCreateCheckboxPromptModal();
                refreshCheckboxPrompts();
                
            } catch (err) {
                console.error('❌ Failed to save checkbox prompt:', err);
                alert(`Failed to save prompt: ${err.message}`);
            }
        }
        
        // Close modal on outside click
        document.getElementById('createCheckboxPromptModal').addEventListener('click', (e) => {
            if (e.target.id === 'createCheckboxPromptModal') {
                closeCreateCheckboxPromptModal();
            }
        });
        
        // ESC key to close checkbox prompt modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !document.getElementById('createCheckboxPromptModal').classList.contains('hidden')) {
                closeCreateCheckboxPromptModal();
            }
        });

        // Default checkbox criteria - empty, will be populated by teacher input
        const defaultCriteria = [];

        function updateCriteria() {
            const criteriaText = document.getElementById('criteriaInput').value.trim();
            const scenarioText = document.getElementById('scenarioInput').value.trim();
            
            if (!criteriaText) {
                showError('Please enter at least one criterion.');
                return;
            }
            
            const criteriaLines = criteriaText.split('\n').filter(line => line.trim());
            
            // Parse criteria with rubrics in parentheses format: "Description (Rubric)"
            currentCriteria = criteriaLines.map((line, index) => {
                const trimmedLine = line.trim();
                
                // Extract description and rubric using regex
                const match = trimmedLine.match(/^(.+?)\s*\((.+)\)\s*$/);
                
                if (match) {
                    // Format: "Description (Rubric)"
                    return {
                        id: index,
                        description: match[1].trim(),
                        rubric: match[2].trim(),
                        completed: false,
                        quote: null,
                        status: 'grey'
                    };
                } else {
                    // Fallback: treat entire line as description
                    return {
                        id: index,
                        description: trimmedLine,
                        rubric: "No specific rubric provided",
                        completed: false,
                        quote: null,
                        status: 'grey'
                    };
                }
            });
            
            currentScenario = scenarioText;
            
            updateDisplay();
            console.log('✅ Updated criteria:', currentCriteria.length, 'items');
            console.log('✅ Updated scenario:', currentScenario);
        }

        // Release checklist to students
        async function releaseChecklistToGroup(groupNumber) {
            if (!sessionCode) {
                alert('No active session. Please start recording first.');
                return;
            }

            const normalizedGroup = Number(groupNumber);
            const groupData = groups.get(normalizedGroup);
            if (!groupData) {
                console.warn('⚠️ No cached group data found; initializing from current criteria.');
                groups.set(normalizedGroup, {
                    transcripts: [],
                    checkboxes: currentCriteria.map(c => ({
                        id: c.id,
                        description: c.description,
                        rubric: c.rubric,
                        completed: c.completed || false,
                        quote: c.quote || null,
                        status: c.status || 'grey'
                    })),
                    stats: {},
                    isActive: true
                });
            }
            let safeGroupData = groups.get(normalizedGroup);
            if (!safeGroupData || !Array.isArray(safeGroupData.checkboxes) || safeGroupData.checkboxes.length === 0) {
                console.warn('⚠️ Group has no checkboxes yet; building from currentCriteria as fallback.');
                safeGroupData = {
                    transcripts: [],
                    checkboxes: currentCriteria.map(c => ({
                        id: c.id,
                        description: c.description,
                        rubric: c.rubric,
                        completed: c.completed || false,
                        quote: c.quote || null,
                        status: c.status || 'grey'
                    })),
                    stats: {},
                    isActive: true
                };
                groups.set(normalizedGroup, safeGroupData);
            }

            try {
                // Debug log to see what we're sending
                console.log('📤 Preparing to release checklist for group', normalizedGroup);
                console.log('📤 Group data checkboxes:', safeGroupData.checkboxes);
                
                // Send checklist data to students - USE THE ACTUAL STATUS, don't recalculate
                const checklistData = {
                    sessionCode: sessionCode,
                    groupNumber: normalizedGroup,
                    criteria: safeGroupData.checkboxes.map(c => {
                        // Use the actual status that was set by the AI, don't recalculate
                        const actualStatus = c.status === 'green' ? 'green' : (c.status || 'grey');
                        
                        console.log(`📤 Criterion ${c.id}: status=${actualStatus}, completed=${c.completed}, quote="${c.quote}"`);
                        
                        return {
                            id: c.id,
                            description: c.description,
                            rubric: c.rubric,
                            status: actualStatus,  // Preserve GREEN
                            completed: actualStatus === 'green' ? true : (c.completed || false),
                            quote: (c.quote && c.quote !== 'null') ? c.quote : null
                        };
                    }),
                    scenario: currentScenario,
                    timestamp: Date.now()
                };

                console.log('📤 Final checklist data to send:', checklistData);
                console.log('📤 Status breakdown:', checklistData.criteria.map(c => `${c.id}: ${c.status}`));

                // Emit to students
                socket.emit('release_checklist', checklistData);

                // Show brief success message
                const releaseBtn = document.querySelector(`[onclick="releaseChecklistToGroup(${normalizedGroup})"]`);
                if (releaseBtn) {
                    const originalText = releaseBtn.innerHTML;
                    releaseBtn.innerHTML = '<i class="fas fa-check mr-1"></i>Released!';
                    releaseBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                    releaseBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                    
                    setTimeout(() => {
                        releaseBtn.innerHTML = originalText;
                        releaseBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                        releaseBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                    }, 2000);
                }

                console.log('📤 Released checklist to group', normalizedGroup, ':', checklistData);

            } catch (error) {
                console.error('❌ Error releasing checklist:', error);
                alert('Failed to release checklist. Please try again.');
            }
        }

        // Update display to show parsed criteria
        function updateDisplay() {
            const criteriaPreview = document.getElementById('criteriaPreview');
            if (!criteriaPreview) {
                // Create criteria preview element if it doesn't exist
                const previewDiv = document.createElement('div');
                previewDiv.id = 'criteriaPreview';
                previewDiv.className = 'mt-4 p-4 bg-gray-50 border border-gray-200 rounded-lg';
                
                const criteriaEditor = document.querySelector('.space-y-6');
                if (criteriaEditor) {
                    criteriaEditor.appendChild(previewDiv);
                }
            }
            
            if (currentCriteria.length > 0) {
                document.getElementById('criteriaPreview').innerHTML = `
                    <h4 class="text-sm font-semibold text-gray-700 mb-3">📋 Parsed Criteria (${currentCriteria.length})</h4>
                    <div class="space-y-2">
                        ${currentCriteria.map((criterion, index) => `
                            <div class="flex items-start space-x-3 p-2 bg-white rounded border">
                                <div class="w-6 h-6 bg-gray-200 rounded-full flex items-center justify-center text-xs font-medium text-gray-600">
                                    ${index + 1}
                                </div>
                                <div class="flex-1">
                                    <div class="text-sm font-medium text-gray-900 mb-1">
                                        ${criterion.description}
                                    </div>
                                    <div class="text-xs text-gray-600 italic">
                                        Rubric: ${criterion.rubric}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            } else {
                document.getElementById('criteriaPreview').innerHTML = `
                    <p class="text-sm text-gray-500">No criteria parsed yet. Enter criteria above and click "Save & Apply".</p>
                `;
            }
        }

        // Toggle format help visibility
        function toggleFormatHelp() {
            const helpSection = document.querySelector('[class*="bg-blue-50"][class*="border-blue-200"]');
            if (helpSection) {
                if (helpSection.classList.contains('hidden')) {
                    helpSection.classList.remove('hidden');
                } else {
                    helpSection.classList.add('hidden');
                }
                
                // Re-initialize icons after DOM change
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            }
        }

        // Reset UI when server stops recording
        socket.on('stop_recording', () => {
            console.log('⏹️ Received stop_recording from server');
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            const intervalInput = document.getElementById('intervalInput');
            startBtn.disabled = false;
            startBtn.innerHTML = `
                <i data-lucide="play" class="w-4 h-4 sm:w-5 sm:h-5 mr-2"></i>
                <span class="hidden sm:inline">Start Recording</span>
                <span class="sm:hidden">Start</span>
            `;
            startBtn.classList.remove('opacity-75', 'cursor-not-allowed');
            stopBtn.disabled = true;
            stopBtn.classList.add('opacity-50', 'cursor-not-allowed');
            intervalInput.disabled = false;
            lucide.createIcons();
        });
    </script>
</body>
</html> 